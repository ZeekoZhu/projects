using System.Diagnostics;
using Microsoft.CodeAnalysis;
using Projects.MarkupViewSourceGenerator.Helper;
using Projects.MarkupViewSourceGenerator.Model;

namespace Projects.MarkupViewSourceGenerator;

[Generator]
public class MarkupViewExtensionGenerator : ISourceGenerator
{
  public void Initialize(GeneratorInitializationContext context)
  {
    #if DEBUG
                if (!Debugger.IsAttached)
                {
                    Debugger.Launch();
                }
    #endif
                Debug.WriteLine("Initalize code generator");
    // No initialization required for this one
  }

  public void Execute(GeneratorExecutionContext context)
  {
    // find all the classes with the IMarkupView interface

    var collector = new PropertyExtensionModelCollector();
    var models = collector.Collect(context);
    foreach (var model in models)
    {
      GenerateMarkupPropertyExtension(context, model);
      GenerateMarkupBuilder(context, model);
    }

    var eventCollector = new EventExtensionModelCollector();
    var eventModels = eventCollector.Collect(context);
    foreach (var model in eventModels)
      GenerateMarkupEventExtension(context, model);
  }

  private static void GenerateMarkupPropertyExtension(
    GeneratorExecutionContext context,
    PropertyExtensionModel model)
  {
    var sb = new SourceWriter();
    sb.Line("// <auto-generated />");

    var namespaceName = model.NamespaceName;
    sb.Line("namespace " + namespaceName + ";");

    var className = model.ClassName;
    sb.Line().Line($"public static partial class {className}Extensions");
    sb.CodeBlock(() =>
    {
      var styledProperties = model.Properties;

      foreach (var prop in styledProperties)
      {
        var propName = prop.PropertyName;
        var propType = prop.TypeName;
        // strip the "Property" suffix
        sb.Line()
          .Line("/// <summary>")
          .Line(
            $"/// Sets a binding with an observable for an <see cref=\"F:{namespaceName}.{className}.{propName}Property\" />.")
          .Line("/// </summary>")
          .Line("/// <param name=\"obj\">The target object.</param>")
          .Line(
            "/// <param name=\"observable\">The observable with the current value of the property.</param>")
          .Line("/// <param name=\"mode\">The binding mode.</param>")
          .Line("/// <param name=\"priority\">The binding priority.</param>")
          .Line("/// <returns>The target object reference.</returns>")
          .Line(
            $"public static T {propName}<T>(this T obj, IObservable<{propType}> observable, BindingMode mode = BindingMode.TwoWay, BindingPriority priority = BindingPriority.LocalValue) where T: {className}")
          .CodeBlock(() =>
          {
            sb.Line($"var binding = {className}.{propName}Property.Bind()")
              .Indent()
              .Line(".WithMode(mode)")
              .Line(".WithPriority(priority);")
              .Unindent();
            sb.Line("obj[binding] = observable.ToBinding();");
            sb.Line("return obj;");
          });

        // public static T Text<T>(this T obj, string value) where T : TextBlock
        // {
        //   obj[(AvaloniaProperty) TextBlock.TextProperty] = (object) value;
        //   return obj;
        // }

        sb.Line()
          .Line("/// <summary>")
          .Line(
            $"/// Sets the value of the <see cref=\"F:{namespaceName}.{className}.{propName}Property\" />.")
          .Line("/// </summary>")
          .Line("/// <param name=\"obj\">The target object.</param>")
          .Line("/// <param name=\"value\">The value to set.</param>")
          .Line("/// <returns>The target object reference.</returns>")
          .Line(
            $"public static T {propName}<T>(this T obj, {propType} value) where T: {className}")
          .CodeBlock(() =>
          {
            sb.Line(
              $"obj[(AvaloniaProperty) {className}.{propName}Property] = (object) value;");
            sb.Line("return obj;");
          });


        // /// <summary>
        // /// Sets a handler with an observable for an <see cref="F:Avalonia.Controls.TextBox.TextProperty" />.
        // /// </summary>
        // /// <param name="obj">The target object.</param>
        // /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
        // /// <returns>The target object reference.</returns>
        // public static T OnText<T>(this T obj, Action<TextBlock, IObservable<string>> handler) where T : TextBlock
        // {
        //   IObservable<string> observable = obj.GetObservable<string>((AvaloniaProperty<string>) TextBlock.TextProperty);
        //   handler((TextBlock) obj, observable);
        //   return obj;
        // }

        sb.Line()
          .Line("/// <summary>")
          .Line(
            $"/// Sets a handler with an observable for an <see cref=\"F:{namespaceName}.{className}.{propName}Property\" />.")
          .Line("/// </summary>")
          .Line("/// <param name=\"obj\">The target object.</param>")
          .Line(
            "/// <param name=\"handler\">The handler with target object and observable with the current value of the property.</param>")
          .Line("/// <returns>The target object reference.</returns>")
          .Line(
            $"public static T On{propName}<T>(this T obj, Action<T, IObservable<{propType}>> handler) where T: {className}")
          .CodeBlock(() =>
          {
            sb.Line(
              $"var observable = obj.GetObservable<{propType}>((AvaloniaProperty<{propType}>) {className}.{propName}Property);");
            sb.Line("handler(obj, observable);");
            sb.Line("return obj;");
          });

        // /// <summary>
        // /// Gets an observable for an <see cref="F:Avalonia.Controls.TextBox.TextProperty" />.
        // /// </summary>
        // /// <param name="obj">The target object.</param>
        // /// <returns>
        // /// An observable which fires immediately with the current value of the property on the
        // /// object and subsequently each time the property value changes.
        // /// </returns>
        // public static IObservable<string> ObserveText(this TextBox obj)
        // {
        //   return obj.GetObservable<string>((AvaloniaProperty<string>) TextBox.TextProperty);
        // }
        sb.Line()
          .Line("/// <summary>")
          .Line(
            $"/// Gets an observable for an <see cref=\"F:{namespaceName}.{className}.{propName}Property\" />.")
          .Line("/// </summary>")
          .Line("/// <param name=\"obj\">The target object.</param>")
          .Line("/// <returns>")
          .Line(
            "/// An observable which fires immediately with the current value of the property on the")
          .Line(
            "/// object and subsequently each time the property value changes.")
          .Line("/// </returns>")
          .Line(
            $"public static IObservable<{propType}> Observe{propName}<T>(this T obj) where T: {className}")
          .CodeBlock(() =>
          {
            sb.Line(
              $"return obj.GetObservable<{propType}>((AvaloniaProperty<{propType}>) {className}.{propName}Property);");
          });
      }
    });

    context.AddSource($"{className}.PropertyExtensions.g.cs", sb.ToString());
  }

  private static void GenerateMarkupEventExtension(
    GeneratorExecutionContext context, EventExtensionModel model)
  {
    var sb = new SourceWriter();
    sb.Line("// <auto-generated />");

    var namespaceName = model.NamespaceName;
    sb.Line("namespace " + namespaceName + ";");

    var className = model.ClassName;
    sb.Line().Line($"public static partial class {className}Extensions");
    sb.CodeBlock(() =>
    {
      var events = model.Events;

      foreach (var ev in events)
      {
        var eventName = ev.EventName;
        var eventType = ev.EventTypeName;

        // /// <summary>
        // /// Registers a handler for the <see cref="F:Avalonia.Input.InputElement.KeyDownEvent" /> event on an object of type <see cref="T:Avalonia.Input.InputElement" />.
        // /// </summary>
        // /// <param name="obj">The target object.</param>
        // /// <param name="action">The action to be performed when the event is raised.</param>
        // /// <param name="routes">The routing strategies for the event.</param>
        // /// <typeparam name="T">The type of the target object.</typeparam>
        // /// <returns>The target object.</returns>
        // public static T OnKeyDownHandler<T>(
        //   this T obj,
        //   Action<T, KeyEventArgs> action,
        //   RoutingStrategies routes = RoutingStrategies.Tunnel | RoutingStrategies.Bubble)
        //   where T : InputElement
        // {
        //   obj.AddHandler<KeyEventArgs>(InputElement.KeyDownEvent, (EventHandler<KeyEventArgs>) ((_, args) => action(obj, args)), routes, false);
        //   return obj;
        // }

        sb.Line()
          .Line("/// <summary>")
          .Line(
            $"/// Registers a handler for the <see cref=\"F:{namespaceName}.{className}.{eventName}Event\" /> event on an object of type <see cref=\"T:{namespaceName}.{className}\" />.")
          .Line("/// </summary>")
          .Line("/// <param name=\"obj\">The target object.</param>")
          .Line(
            "/// <param name=\"action\">The action to be performed when the event is raised.</param>")
          .Line(
            "/// <param name=\"routes\">The routing strategies for the event.</param>")
          .Line(
            "/// <typeparam name=\"T\">The type of the target object.</typeparam>")
          .Line("/// <returns>The target object.</returns>")
          .Line(
            $"public static {className} On{eventName}Handler<T>(")
          .Line("  this T obj,")
          .Line($"  Action<T, {eventType}> action,")
          .Line(
            "  RoutingStrategies routes = RoutingStrategies.Tunnel | RoutingStrategies.Bubble)")
          .Line("  where T : " + className)
          .CodeBlock(() =>
          {
            sb.Line(
              $"obj.AddHandler<{eventType}>({className}.{eventName}Event, (EventHandler<{eventType}>) ((_, args) => action(obj, args)), routes, false);");
            sb.Line("return obj;");
          });


        // /// <summary>
        // /// Registers a handler for the <see cref="F:Avalonia.Input.InputElement.KeyDownEvent" /> event on an object of type <see cref="T:Avalonia.Input.InputElement" /> and returns an observable for the event.
        // /// </summary>
        // /// <param name="obj">The target object.</param>
        // /// <param name="handler">The handler to be called when the event is raised.</param>
        // /// <param name="routes">The routing strategies for the event.</param>
        // /// <typeparam name="T">The type of the target object.</typeparam>
        // /// <returns>The target object.</returns>
        // public static T OnKeyDown<T>(
        //   this T obj,
        //   Action<T, IObservable<KeyEventArgs>> handler,
        //   RoutingStrategies routes = RoutingStrategies.Tunnel | RoutingStrategies.Bubble)
        //   where T : InputElement
        // {
        //   IObservable<KeyEventArgs> observable = obj.GetObservable<KeyEventArgs>(InputElement.KeyDownEvent, routes);
        //   handler(obj, observable);
        //   return obj;
        // }

        sb.Line()
          .Line("/// <summary>")
          .Line(
            $"/// Registers a handler for the <see cref=\"F:{namespaceName}.{className}.{eventName}Event\" /> event on an object of type <see cref=\"T:{namespaceName}.{className}\" /> and returns an observable for the event.")
          .Line("/// </summary>")
          .Line("/// <param name=\"obj\">The target object.</param>")
          .Line(
            "/// <param name=\"handler\">The handler to be called when the event is raised.</param>")
          .Line(
            "/// <param name=\"routes\">The routing strategies for the event.</param>")
          .Line(
            "/// <typeparam name=\"T\">The type of the target object.</typeparam>")
          .Line("/// <returns>The target object.</returns>")
          .Line($"public static {className} On{eventName}<T>(")
          .Line("  this T obj,")
          .Line($"  Action<T, IObservable<{eventType}>> handler,")
          .Line(
            "  RoutingStrategies routes = RoutingStrategies.Tunnel | RoutingStrategies.Bubble)")
          .Line("  where T : " + className)
          .CodeBlock(() =>
          {
            sb.Line(
              $"IObservable<{eventType}> observable = obj.GetObservable<{eventType}>({className}.{eventName}Event, routes);");
            sb.Line("handler(obj, observable);");
            sb.Line("return obj;");
          });


        // /// <summary>
        // /// Gets an observable for the <see cref="F:Avalonia.Input.InputElement.KeyDownEvent" /> event on an object of type <see cref="T:Avalonia.Input.InputElement" />.
        // /// </summary>
        // /// <param name="obj">The target object.</param>
        // /// <param name="routes">The routing strategies for the event.</param>
        // /// <returns>An observable for the event.</returns>
        // public static IObservable<KeyEventArgs> ObserveOnKeyDown(
        //   this InputElement obj,
        //   RoutingStrategies routes = RoutingStrategies.Tunnel | RoutingStrategies.Bubble)
        // {
        //   return obj.GetObservable<KeyEventArgs>(InputElement.KeyDownEvent, routes);
        // }

        sb.Line()
          .Line("/// <summary>")
          .Line(
            $"/// Gets an observable for the <see cref=\"F:{namespaceName}.{className}.{eventName}Event\" /> event on an object of type <see cref=\"T:{namespaceName}.{className}\" />.")
          .Line("/// </summary>")
          .Line("/// <param name=\"obj\">The target object.</param>")
          .Line(
            "/// <param name=\"routes\">The routing strategies for the event.</param>")
          .Line("/// <returns>An observable for the event.</returns>")
          .Line($"public static IObservable<{eventType}> ObserveOn{eventName}(")
          .Line($"  this {className} obj,")
          .Line(
            "  RoutingStrategies routes = RoutingStrategies.Tunnel | RoutingStrategies.Bubble)")
          .CodeBlock(() =>
          {
            sb.Line(
              $"return obj.GetObservable<{eventType}>({className}.{eventName}Event, routes);");
          });
      }
    });

    context.AddSource($"{className}.EventExtensions.g.cs", sb.ToString());
  }

  private static void GenerateMarkupBuilder(
    GeneratorExecutionContext context,
    PropertyExtensionModel model)
  {
    var sb = new SourceWriter();
    sb.Line("// <auto-generated />");

    var namespaceName = model.NamespaceName;
    sb.Line("namespace " + namespaceName + ";");

    var className = model.ClassName;
    sb.Line().Line($"public static partial class {className}Builder");

    sb.CodeBlock(() =>
    {
      // /// <summary>
      // /// Creates a new instance of the <see cref="T:Avalonia.Media.ArcSegment" /> class.
      // /// </summary>
      // /// <returns>The new instance of the <see cref="T:Avalonia.Media.ArcSegment" /> class.</returns>
      // public static Avalonia.Media.ArcSegment ArcSegment() => new Avalonia.Media.ArcSegment();

      sb.Line()
        .Line("/// <summary>")
        .Line(
          $"/// Creates a new instance of the <see cref=\"T:{namespaceName}.{className}\" /> class.")
        .Line("/// </summary>")
        .Line(
          $"/// <returns>The new instance of the <see cref=\"T:{namespaceName}.{className}\" /> class.</returns>")
        .Line(
          $"public static {className} {className}() => new {namespaceName}.{className}();");

      //
      // /// <summary>
      // /// Creates a new instance of the <see cref="T:Avalonia.Media.ArcSegment" /> class.
      // /// </summary>
      // /// <param name="ref">The reference of the <see cref="T:Avalonia.Media.ArcSegment" /> instantiated class.</param>
      // /// <returns>The new instance of the <see cref="T:Avalonia.Media.ArcSegment" /> class.</returns>
      // public static Avalonia.Media.ArcSegment ArcSegment(out Avalonia.Media.ArcSegment @ref)
      // {
      //   return @ref = new Avalonia.Media.ArcSegment();
      // }

      sb.Line()
        .Line("/// <summary>")
        .Line(
          $"/// Creates a new instance of the <see cref=\"T:{namespaceName}.{className}\" /> class.")
        .Line("/// </summary>")
        .Line(
          $"/// <param name=\"ref\">The reference of the <see cref=\"T:{namespaceName}.{className}\" /> instantiated class.</param>")
        .Line(
          $"/// <returns>The new instance of the <see cref=\"T:{namespaceName}.{className}\" /> class.</returns>")
        .Line($"public static {className} {className}(out {className} @ref)")
        .CodeBlock(() =>
        {
          sb.Line($"return @ref = new {namespaceName}.{className}();");
        });
    });

    context.AddSource($"{className}.Builder.g.cs", sb.ToString());
  }
}
