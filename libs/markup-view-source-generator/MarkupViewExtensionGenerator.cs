using System.Diagnostics;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Projects.MarkupViewSourceGenerator.Helper;

namespace Projects.MarkupViewSourceGenerator;

[Generator]
public class MarkupViewExtensionGenerator : ISourceGenerator
{
  public void Initialize(GeneratorInitializationContext context)
  {
    // No initialization required for this one
  }

  public void Execute(GeneratorExecutionContext context)
  {
    // find all the classes with the IMarkupView interface
    var allClasses = context.Compilation.SyntaxTrees
      .SelectMany(s =>
        s.GetRoot().DescendantNodes().OfType<ClassDeclarationSyntax>())
      .Where(s =>
      {
        var model = context.Compilation.GetSemanticModel(s.SyntaxTree);
        var symbol = model.GetDeclaredSymbol(s);
        return symbol is INamedTypeSymbol cs &&
               cs.AllInterfaces.Any(it => it.Name == "IMarkupView");
      })
      .ToList();

    foreach (var view in allClasses) GenerateMarkupViewExtension(context, view);
  }

  private static void GenerateMarkupViewExtension(GeneratorExecutionContext context,
    ClassDeclarationSyntax view)
  {
    var sb = new SourceWriter();
    sb.Line("// <auto-generated />");
    var ns = view.SyntaxTree.GetRoot()
      .DescendantNodes()
      .FirstOrDefault(x => x is BaseNamespaceDeclarationSyntax);

    var namespaceName = ns is BaseNamespaceDeclarationSyntax bns
      ? bns.Name.ToString()
      : null;
    if (namespaceName is not null)
    {
      sb.Line("namespace " + namespaceName + ";");
    }
    else
    {
      Debug.Fail("No namespace found.");
      return;
    }

    var className = view.Identifier.ToString();
    sb.Line().Line($"public static class {className}Extensions");
    sb.CodeBlock(() =>
    {
      var styledProperties = view.DescendantNodes()
        .OfType<FieldDeclarationSyntax>()
        .Where(p =>
          p.Modifiers.Any(m => m.ValueText == "public") &&
          p.Modifiers.Any(m => m.ValueText == "static") &&
          p.Modifiers.Any(m => m.ValueText == "readonly") &&
          p.Declaration.Type is GenericNameSyntax
          {
            Identifier.ValueText: "StyledProperty"
          })
        .ToList();

      foreach (var prop in styledProperties)
      {
        var propName = prop.Declaration.Variables[0]
          .Identifier.ToString()
          .Replace("Property", "");
        var propType = prop.Declaration.Type.ToString().Split('<', '>')[1];
        // strip the "Property" suffix
        sb.Line()
          .Line("/// <summary>")
          .Line($"/// Sets a binding with an observable for an <see cref=\"F:{namespaceName}.{className}.{propName}Property\" />.")
          .Line("/// </summary>")
          .Line("/// <param name=\"obj\">The target object.</param>")
          .Line("/// <param name=\"observable\">The observable with the current value of the property.</param>")
          .Line("/// <param name=\"mode\">The binding mode.</param>")
          .Line("/// <param name=\"priority\">The binding priority.</param>")
          .Line("/// <returns>The target object reference.</returns>")
          .Line(
            $"public static {className} {propName}(this {className} obj, IObservable<{propType}> observable, BindingMode mode = BindingMode.TwoWay, BindingPriority priority = BindingPriority.LocalValue)")
          .CodeBlock(() =>
          {
            sb.Line($"var binding = {className}.{propName}Property.Bind()")
              .Indent()
              .Line(".WithMode(mode)")
              .Line(".WithPriority(priority);")
              .Unindent();
            sb.Line("obj[binding] = observable.ToBinding();");
            sb.Line("return obj;");
          });

        // public static T Text<T>(this T obj, string value) where T : TextBlock
        // {
        //   obj[(AvaloniaProperty) TextBlock.TextProperty] = (object) value;
        //   return obj;
        // }

        sb.Line()
          .Line("/// <summary>")
          .Line($"/// Sets the value of the <see cref=\"F:{namespaceName}.{className}.{propName}Property\" />.")
          .Line("/// </summary>")
          .Line("/// <param name=\"obj\">The target object.</param>")
          .Line("/// <param name=\"value\">The value to set.</param>")
          .Line("/// <returns>The target object reference.</returns>")
          .Line(
            $"public static {className} {propName}(this {className} obj, {propType} value)")
          .CodeBlock(() =>
          {
            sb.Line(
              $"obj[(AvaloniaProperty) {className}.{propName}Property] = (object) value;");
            sb.Line("return obj;");
          });


        // /// <summary>
        // /// Sets a handler with an observable for an <see cref="F:Avalonia.Controls.TextBox.TextProperty" />.
        // /// </summary>
        // /// <param name="obj">The target object.</param>
        // /// <param name="handler">The handler with target object and observable with the current value of the property.</param>
        // /// <returns>The target object reference.</returns>
        // public static T OnText<T>(this T obj, Action<TextBlock, IObservable<string>> handler) where T : TextBlock
        // {
        //   IObservable<string> observable = obj.GetObservable<string>((AvaloniaProperty<string>) TextBlock.TextProperty);
        //   handler((TextBlock) obj, observable);
        //   return obj;
        // }

        sb.Line()
          .Line("/// <summary>")
          .Line($"/// Sets a handler with an observable for an <see cref=\"F:{namespaceName}.{className}.{propName}Property\" />.")
          .Line("/// </summary>")
          .Line("/// <param name=\"obj\">The target object.</param>")
          .Line("/// <param name=\"handler\">The handler with target object and observable with the current value of the property.</param>")
          .Line("/// <returns>The target object reference.</returns>")
          .Line(
            $"public static {className} On{propName}(this {className} obj, Action<{className}, IObservable<{propType}>> handler)")
          .CodeBlock(() =>
          {
            sb.Line(
              $"var observable = obj.GetObservable<{propType}>((AvaloniaProperty<{propType}>) {className}.{propName}Property);");
            sb.Line("handler(obj, observable);");
            sb.Line("return obj;");
          });

        // /// <summary>
        // /// Gets an observable for an <see cref="F:Avalonia.Controls.TextBox.TextProperty" />.
        // /// </summary>
        // /// <param name="obj">The target object.</param>
        // /// <returns>
        // /// An observable which fires immediately with the current value of the property on the
        // /// object and subsequently each time the property value changes.
        // /// </returns>
        // public static IObservable<string> ObserveText(this TextBox obj)
        // {
        //   return obj.GetObservable<string>((AvaloniaProperty<string>) TextBox.TextProperty);
        // }
        sb.Line()
          .Line("/// <summary>")
          .Line($"/// Gets an observable for an <see cref=\"F:{namespaceName}.{className}.{propName}Property\" />.")
          .Line("/// </summary>")
          .Line("/// <param name=\"obj\">The target object.</param>")
          .Line("/// <returns>")
          .Line("/// An observable which fires immediately with the current value of the property on the")
          .Line("/// object and subsequently each time the property value changes.")
          .Line("/// </returns>")
          .Line(
            $"public static IObservable<{propType}> Observe{propName}(this {className} obj)")
          .CodeBlock(() =>
          {
            sb.Line(
              $"return obj.GetObservable<{propType}>((AvaloniaProperty<{propType}>) {className}.{propName}Property);");
          });

      }
    });

    context.AddSource($"{className}Extensions.cs", sb.ToString());
  }
}
