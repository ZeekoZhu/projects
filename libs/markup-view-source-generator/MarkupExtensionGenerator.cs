using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Projects.MarkupViewSourceGenerator.Helper;

namespace Projects.MarkupViewSourceGenerator;

[Generator]
public class MarkupExtensionGenerator : ISourceGenerator
{
  public void Initialize(GeneratorInitializationContext context)
  {
    context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
  }

  public void Execute(GeneratorExecutionContext context)
  {
    if (context.SyntaxReceiver is not SyntaxReceiver receiver)
    {
      return;
    }

    var configParser = new ConfigParser();
    var configInfos = configParser.GetConfigClasses(context, receiver);
    var writer = new MarkupExtensionSourceWriter(context);

    foreach (var configInfo in configInfos)
    {
      writer.GenerateExtensionSource(configInfo);
    }
  }
}

public class SyntaxReceiver : ISyntaxReceiver
{
  public List<ClassDeclarationSyntax> CandidateClasses { get; } = [];

  public void OnVisitSyntaxNode(SyntaxNode syntaxNode)
  {
    if (syntaxNode is ClassDeclarationSyntax
        {
          AttributeLists.Count: > 0
        } classDeclarationSyntax)
    {
      CandidateClasses.Add(classDeclarationSyntax);
    }
  }
}

public class MarkupExtensionSourceWriter(GeneratorExecutionContext context)
{
  private readonly ControlInfoExtractor _controlInfoExtractor = new();

  public void GenerateExtensionSource(ConfigInfo configInfo)
  {
    foreach (var controlInfo in configInfo.ControlTypes.Select(controlType =>
               _controlInfoExtractor.Extract(controlType)))
    {
      if (controlInfo.HasDefaultCtor)
      {
        var builderContent = GenerateBuilderExtension(controlInfo);
        context.AddSource($"{controlInfo.ExtensionClassName}_Builder.g.cs",
          builderContent);
      }

      if (controlInfo.Properties.Any())
      {
        var propertyContent = GeneratePropertyExtension(controlInfo);
        context.AddSource($"{controlInfo.ExtensionClassName}_Properties.g.cs",
          propertyContent);
      }
    }
  }

  private string GenerateBuilderExtension(ControlInfo controlInfo)
  {
    var sw = new SourceWriter();
    sw.AutoGenerated();
    sw.Line($"namespace {controlInfo.DeclaringNamespace};");

    sw.Line()
      .Line(
        $"public static partial class MarkupBuilder");
    sw.CodeBlock(() =>
    {
      var controlClassName = controlInfo.ControlClassName;
      var controlClassNameRef = controlClassName.Replace("global::", string.Empty);
      sw.Line()
        .XmlDocSummary(
          $"Creates a new instance of the <see cref=\"T:{controlClassNameRef}\" /> class.")
        .Line(
          $"/// <returns>The new instance of <see cref=\"T:{controlClassNameRef}\" />.</returns>")
        .Line(
          $"public static {controlClassName} {controlInfo.ControlName}() => new {controlClassName}();");


      // build with an out ref
      sw.Line()
        .XmlDocSummary(
          $"Creates a new instance of the <see cref=\"T:{controlClassNameRef}\" /> class.")
        .Line(
          $"/// <param name=\"ref\">The reference of the <see cref=\"T:{controlClassNameRef}\" /> instantiated class.</param>")
        .Line(
          $"/// <returns>The new instance of <see cref=\"T:{controlClassName}\" />.</returns>")
        .Line(
          $"public static {controlClassName} {controlInfo.ControlName}(out {controlClassName} @ref)")
        .CodeBlock(() =>
        {
          sw.Line($"return @ref = new {controlClassName}();");
        });
    });

    return sw.ToString();
  }

  private string GeneratePropertyExtension(ControlInfo controlInfo)
  {
    var sw = new SourceWriter();

    sw.AutoGenerated();
    sw.Line("using System.Reactive;");
    sw.Line("using Avalonia.Data;");
    sw.NamespaceLine(controlInfo.DeclaringNamespace);

    sw.Line()
      .Line(
        $"public static partial class {controlInfo.ExtensionClassName}_Properties")
      .CodeBlock(() =>
      {
        foreach (var property in controlInfo.Properties)
        {
          var controlClass = controlInfo.ControlClassName;
          var controlClassNameRef = controlClass.Replace("global::", string.Empty);
          var propField = property.PropertyFieldName;
          var propName = property.Name;
          var propType = property.Type;
          sw.XmlDocSummary(
              $"Sets a binding with an observable for an <see cref=\"F:{controlClassNameRef}.{propField}\" />.")
            .Line("/// <param name=\"obj\">The target object.</param>")
            .Line(
              "/// <param name=\"observable\">The observable with the current value of the property.</param>")
            .Line("/// <param name=\"mode\">The binding mode.</param>")
            .Line("/// <param name=\"priority\">The binding priority.</param>")
            .Line("/// <returns>The target object reference.</returns>")
            .Line(
              $"public static T {propName}<T>(this T obj, IObservable<{propType}> observable, BindingMode mode = BindingMode.TwoWay, BindingPriority priority = BindingPriority.LocalValue) where T: {controlClass}")
            .CodeBlock(() =>
            {
              sw.Line(
                  $"var binding = {controlClass}.{propField}.Bind()")
                .Indent()
                .Line(".WithMode(mode)")
                .Line(".WithPriority(priority);")
                .Unindent()
                .Line("obj[binding] = observable.ToBinding();")
                .Line("return obj;");
            });


          sw.XmlDocSummary(
              $"Sets the value of the <see cref=\"F:{controlClassNameRef}.{propField}\" />.")
            .Line("/// <param name=\"obj\">The target object.</param>")
            .Line("/// <param name=\"value\">The value to set.</param>")
            .Line("/// <returns>The target object reference.</returns>")
            .Line(
              $"public static T {propName}<T>(this T obj, {propType} value) where T: {controlClass}")
            .CodeBlock(() =>
            {
              sw.Line(
                  $"obj[(AvaloniaProperty) {controlClass}.{propField}] = (object) value;")
                .Line("return obj;");
            });


          sw.Line()
            .XmlDocSummary(
              $"Sets a handler with an observable for an <see cref=\"F:{controlClassNameRef}.{propField}\" />.")
            .Line("/// <param name=\"obj\">The target object.</param>")
            .Line(
              "/// <param name=\"handler\">The handler with target object and observable with the current value of the property.</param>")
            .Line("/// <returns>The target object reference.</returns>")
            .Line(
              $"public static T On{propName}<T>(this T obj, Action<T, IObservable<{propType}>> handler) where T: {controlClass}")
            .CodeBlock(() =>
            {
              sw.Line(
                  $"var observable = obj.GetObservable<{propType}>((AvaloniaProperty<{propType}>) {controlClass}.{propField});")
                .Line("handler(obj, observable);")
                .Line("return obj;");
            });


          sw.Line()
            .XmlDocSummary(
              $"Gets an observable for an <see cref=\"F:{controlClassNameRef}.{propField}\" />.")
            .Line("/// <param name=\"obj\">The target object.</param>")
            .Line("/// <returns>")
            .Line(
              "/// An observable which fires immediately with the current value of the property on the")
            .Line(
              "/// object and subsequently each time the property value changes.")
            .Line("/// </returns>")
            .Line(
              $"public static IObservable<{propType}> Observe{propName}<T>(this T obj) where T: {controlClass}")
            .CodeBlock(() =>
            {
              sw.Line(
                $"return obj.GetObservable<{propType}>((AvaloniaProperty<{propType}>) {controlClass}.{propField});");
            });
        }
      });

    return sw.ToString();
  }
}
