/*
 * The Jira Cloud platform REST API
 *
 * Jira Cloud platform REST API documentation
 *
 * The version of the OpenAPI document: 1001.0.0-SNAPSHOT-9aad01a33a3dae75a5b6aedf98c77d2cbd2f865d
 * Contact: ecosystem@atlassian.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using Projects.JiraPlatformApi.Client;
using Projects.JiraPlatformApi.Client.Auth;
using Projects.JiraPlatformApi.Model;

namespace Projects.JiraPlatformApi.Api
{

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IIssuesApiSync : IApiAccessor
    {
        #region Synchronous Operations
        /// <summary>
        /// Archive issue(s) by issue ID/key
        /// </summary>
        /// <remarks>
        /// Enables admins to archive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) archived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be archived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueArchivalSyncResponse</returns>
        IssueArchivalSyncResponse ArchiveIssues(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0);

        /// <summary>
        /// Archive issue(s) by issue ID/key
        /// </summary>
        /// <remarks>
        /// Enables admins to archive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) archived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be archived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueArchivalSyncResponse</returns>
        ApiResponse<IssueArchivalSyncResponse> ArchiveIssuesWithHttpInfo(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0);
        /// <summary>
        /// Archive issue(s) by JQL
        /// </summary>
        /// <remarks>
        /// Enables admins to archive up to 100,000 issues in a single request using JQL, returning the URL to check the status of the submitted request.  You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) and [cancel task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-cancel-post) APIs to manage the request.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request per jira instance can be active at any given time.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveIssueAsyncRequest">A JQL query specifying the issues to archive. Note that subtasks can only be archived through their parent issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        string ArchiveIssuesAsync(ArchiveIssueAsyncRequest archiveIssueAsyncRequest, int operationIndex = 0);

        /// <summary>
        /// Archive issue(s) by JQL
        /// </summary>
        /// <remarks>
        /// Enables admins to archive up to 100,000 issues in a single request using JQL, returning the URL to check the status of the submitted request.  You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) and [cancel task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-cancel-post) APIs to manage the request.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request per jira instance can be active at any given time.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveIssueAsyncRequest">A JQL query specifying the issues to archive. Note that subtasks can only be archived through their parent issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        ApiResponse<string> ArchiveIssuesAsyncWithHttpInfo(ArchiveIssueAsyncRequest archiveIssueAsyncRequest, int operationIndex = 0);
        /// <summary>
        /// Assign issue
        /// </summary>
        /// <remarks>
        /// Assigns an issue to a user. Use this operation when the calling user does not have the *Edit Issues* permission but has the *Assign issue* permission for the project that the issue is in.  If &#x60;name&#x60; or &#x60;accountId&#x60; is set to:   *  &#x60;\&quot;-1\&quot;&#x60;, the issue is assigned to the default assignee for the project.  *  &#x60;null&#x60;, the issue is set to unassigned.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse Projects* and *Assign Issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue to be assigned.</param>
        /// <param name="user">The request object with the user that the issue is assigned to.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Object</returns>
        Object AssignIssue(string issueIdOrKey, User user, int operationIndex = 0);

        /// <summary>
        /// Assign issue
        /// </summary>
        /// <remarks>
        /// Assigns an issue to a user. Use this operation when the calling user does not have the *Edit Issues* permission but has the *Assign issue* permission for the project that the issue is in.  If &#x60;name&#x60; or &#x60;accountId&#x60; is set to:   *  &#x60;\&quot;-1\&quot;&#x60;, the issue is assigned to the default assignee for the project.  *  &#x60;null&#x60;, the issue is set to unassigned.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse Projects* and *Assign Issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue to be assigned.</param>
        /// <param name="user">The request object with the user that the issue is assigned to.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object</returns>
        ApiResponse<Object> AssignIssueWithHttpInfo(string issueIdOrKey, User user, int operationIndex = 0);
        /// <summary>
        /// Create issue
        /// </summary>
        /// <remarks>
        /// Creates an issue or, where the option to create subtasks is enabled in Jira, a subtask. A transition may be applied, to move the issue or subtask to a workflow step other than the default start step, and issue properties set.  The content of the issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issue&#39;s create screen.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which the issue or subtask is created.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. When provided, the issue type and request type are added to the user&#39;s history for a project. These values are then used to provide defaults on the issue create screen. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CreatedIssue</returns>
        CreatedIssue CreateIssue(IssueUpdateDetails issueUpdateDetails, bool? updateHistory = default(bool?), int operationIndex = 0);

        /// <summary>
        /// Create issue
        /// </summary>
        /// <remarks>
        /// Creates an issue or, where the option to create subtasks is enabled in Jira, a subtask. A transition may be applied, to move the issue or subtask to a workflow step other than the default start step, and issue properties set.  The content of the issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issue&#39;s create screen.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which the issue or subtask is created.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. When provided, the issue type and request type are added to the user&#39;s history for a project. These values are then used to provide defaults on the issue create screen. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CreatedIssue</returns>
        ApiResponse<CreatedIssue> CreateIssueWithHttpInfo(IssueUpdateDetails issueUpdateDetails, bool? updateHistory = default(bool?), int operationIndex = 0);
        /// <summary>
        /// Bulk create issue
        /// </summary>
        /// <remarks>
        /// Creates upto **50** issues and, where the option to create subtasks is enabled in Jira, subtasks. Transitions may be applied, to move the issues or subtasks to a workflow step other than the default start step, and issue properties set.  The content of each issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issues&#39; create screens.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; the must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which each issue or subtask is created.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuesUpdateBean"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CreatedIssues</returns>
        CreatedIssues CreateIssues(IssuesUpdateBean issuesUpdateBean, int operationIndex = 0);

        /// <summary>
        /// Bulk create issue
        /// </summary>
        /// <remarks>
        /// Creates upto **50** issues and, where the option to create subtasks is enabled in Jira, subtasks. Transitions may be applied, to move the issues or subtasks to a workflow step other than the default start step, and issue properties set.  The content of each issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issues&#39; create screens.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; the must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which each issue or subtask is created.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuesUpdateBean"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CreatedIssues</returns>
        ApiResponse<CreatedIssues> CreateIssuesWithHttpInfo(IssuesUpdateBean issuesUpdateBean, int operationIndex = 0);
        /// <summary>
        /// Delete issue
        /// </summary>
        /// <remarks>
        /// Deletes an issue.  An issue cannot be deleted if it has one or more subtasks. To delete an issue with subtasks, set &#x60;deleteSubtasks&#x60;. This causes the issue&#39;s subtasks to be deleted with the issue.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Delete issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="deleteSubtasks">Whether the issue&#39;s subtasks are deleted when the issue is deleted. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        void DeleteIssue(string issueIdOrKey, string? deleteSubtasks = default(string?), int operationIndex = 0);

        /// <summary>
        /// Delete issue
        /// </summary>
        /// <remarks>
        /// Deletes an issue.  An issue cannot be deleted if it has one or more subtasks. To delete an issue with subtasks, set &#x60;deleteSubtasks&#x60;. This causes the issue&#39;s subtasks to be deleted with the issue.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Delete issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="deleteSubtasks">Whether the issue&#39;s subtasks are deleted when the issue is deleted. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        ApiResponse<Object> DeleteIssueWithHttpInfo(string issueIdOrKey, string? deleteSubtasks = default(string?), int operationIndex = 0);
        /// <summary>
        /// Transition issue
        /// </summary>
        /// <remarks>
        /// Performs an issue transition and, if the transition has a screen, updates the fields from the transition screen.  sortByCategory To update the fields on the transition screen, specify the fields in the &#x60;fields&#x60; or &#x60;update&#x60; parameters in the request body. Get details about the fields using [ Get transitions](#api-rest-api-2-issue-issueIdOrKey-transitions-get) with the &#x60;transitions.fields&#x60; expand.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Transition issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Object</returns>
        Object DoTransition(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, int operationIndex = 0);

        /// <summary>
        /// Transition issue
        /// </summary>
        /// <remarks>
        /// Performs an issue transition and, if the transition has a screen, updates the fields from the transition screen.  sortByCategory To update the fields on the transition screen, specify the fields in the &#x60;fields&#x60; or &#x60;update&#x60; parameters in the request body. Get details about the fields using [ Get transitions](#api-rest-api-2-issue-issueIdOrKey-transitions-get) with the &#x60;transitions.fields&#x60; expand.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Transition issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object</returns>
        ApiResponse<Object> DoTransitionWithHttpInfo(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, int operationIndex = 0);
        /// <summary>
        /// Edit issue
        /// </summary>
        /// <remarks>
        /// Edits an issue. Issue properties may be updated as part of the edit. Please note that issue transition will be ignored as it is not supported yet.  The edits to the issue&#39;s fields are defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be edited are determined using [ Get edit issue metadata](#api-rest-api-2-issue-issueIdOrKey-editmeta-get).  The parent field may be set by key or ID. For standard issue types, the parent may be removed by setting &#x60;update.parent.set.none&#x60; to *true*.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can override the screen security configuration using &#x60;overrideScreenSecurity&#x60; and &#x60;overrideEditableFlag&#x60;.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="notifyUsers">Whether a notification email about the issue update is sent to all watchers. To disable the notification, administer Jira or administer project permissions are required. If the user doesn&#39;t have the necessary permission the request is ignored. (optional, default to true)</param>
        /// <param name="overrideScreenSecurity">Whether screen security is overridden to enable hidden fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="returnIssue">Whether the response should contain the issue with fields edited in this request. The returned issue will have the same format as in the [Get issue API](#api-rest-api-3-issue-issueidorkey-get). (optional, default to false)</param>
        /// <param name="expand">The Get issue API expand parameter to use in the response if the &#x60;returnIssue&#x60; parameter is &#x60;true&#x60;. (optional, default to &quot;&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Object</returns>
        Object EditIssue(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, bool? notifyUsers = default(bool?), bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), bool? returnIssue = default(bool?), string? expand = default(string?), int operationIndex = 0);

        /// <summary>
        /// Edit issue
        /// </summary>
        /// <remarks>
        /// Edits an issue. Issue properties may be updated as part of the edit. Please note that issue transition will be ignored as it is not supported yet.  The edits to the issue&#39;s fields are defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be edited are determined using [ Get edit issue metadata](#api-rest-api-2-issue-issueIdOrKey-editmeta-get).  The parent field may be set by key or ID. For standard issue types, the parent may be removed by setting &#x60;update.parent.set.none&#x60; to *true*.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can override the screen security configuration using &#x60;overrideScreenSecurity&#x60; and &#x60;overrideEditableFlag&#x60;.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="notifyUsers">Whether a notification email about the issue update is sent to all watchers. To disable the notification, administer Jira or administer project permissions are required. If the user doesn&#39;t have the necessary permission the request is ignored. (optional, default to true)</param>
        /// <param name="overrideScreenSecurity">Whether screen security is overridden to enable hidden fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="returnIssue">Whether the response should contain the issue with fields edited in this request. The returned issue will have the same format as in the [Get issue API](#api-rest-api-3-issue-issueidorkey-get). (optional, default to false)</param>
        /// <param name="expand">The Get issue API expand parameter to use in the response if the &#x60;returnIssue&#x60; parameter is &#x60;true&#x60;. (optional, default to &quot;&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object</returns>
        ApiResponse<Object> EditIssueWithHttpInfo(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, bool? notifyUsers = default(bool?), bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), bool? returnIssue = default(bool?), string? expand = default(string?), int operationIndex = 0);
        /// <summary>
        /// Export archived issue(s)
        /// </summary>
        /// <remarks>
        /// Enables admins to retrieve details of all archived issues. Upon a successful request, the admin who submitted it will receive an email with a link to download a CSV file with the issue details.  Note that this API only exports the values of system fields and archival-specific fields (&#x60;ArchivedBy&#x60; and &#x60;ArchivedDate&#x60;). Custom fields aren&#39;t supported.  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request can be active at any given time.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archivedIssuesFilterRequest">You can filter the issues in your request by the &#x60;projects&#x60;, &#x60;archivedBy&#x60;, &#x60;archivedDate&#x60;, &#x60;issueTypes&#x60;, and &#x60;reporters&#x60; fields. All filters are optional. If you don&#39;t provide any filters, you&#39;ll get a list of up to one million archived issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ExportArchivedIssuesTaskProgressResponse</returns>
        ExportArchivedIssuesTaskProgressResponse ExportArchivedIssues(ArchivedIssuesFilterRequest archivedIssuesFilterRequest, int operationIndex = 0);

        /// <summary>
        /// Export archived issue(s)
        /// </summary>
        /// <remarks>
        /// Enables admins to retrieve details of all archived issues. Upon a successful request, the admin who submitted it will receive an email with a link to download a CSV file with the issue details.  Note that this API only exports the values of system fields and archival-specific fields (&#x60;ArchivedBy&#x60; and &#x60;ArchivedDate&#x60;). Custom fields aren&#39;t supported.  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request can be active at any given time.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archivedIssuesFilterRequest">You can filter the issues in your request by the &#x60;projects&#x60;, &#x60;archivedBy&#x60;, &#x60;archivedDate&#x60;, &#x60;issueTypes&#x60;, and &#x60;reporters&#x60; fields. All filters are optional. If you don&#39;t provide any filters, you&#39;ll get a list of up to one million archived issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ExportArchivedIssuesTaskProgressResponse</returns>
        ApiResponse<ExportArchivedIssuesTaskProgressResponse> ExportArchivedIssuesWithHttpInfo(ArchivedIssuesFilterRequest archivedIssuesFilterRequest, int operationIndex = 0);
        /// <summary>
        /// Get changelogs
        /// </summary>
        /// <remarks>
        /// Returns a [paginated](#pagination) list of all changelogs for an issue sorted by date, starting from the oldest.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 100)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageBeanChangelog</returns>
        PageBeanChangelog GetChangeLogs(string issueIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0);

        /// <summary>
        /// Get changelogs
        /// </summary>
        /// <remarks>
        /// Returns a [paginated](#pagination) list of all changelogs for an issue sorted by date, starting from the oldest.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 100)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageBeanChangelog</returns>
        ApiResponse<PageBeanChangelog> GetChangeLogsWithHttpInfo(string issueIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0);
        /// <summary>
        /// Get changelogs by IDs
        /// </summary>
        /// <remarks>
        /// Returns changelogs for an issue specified by a list of changelog IDs.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueChangelogIds"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageOfChangelogs</returns>
        PageOfChangelogs GetChangeLogsByIds(string issueIdOrKey, IssueChangelogIds issueChangelogIds, int operationIndex = 0);

        /// <summary>
        /// Get changelogs by IDs
        /// </summary>
        /// <remarks>
        /// Returns changelogs for an issue specified by a list of changelog IDs.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueChangelogIds"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageOfChangelogs</returns>
        ApiResponse<PageOfChangelogs> GetChangeLogsByIdsWithHttpInfo(string issueIdOrKey, IssueChangelogIds issueChangelogIds, int operationIndex = 0);
        /// <summary>
        /// Get create issue metadata
        /// </summary>
        /// <remarks>
        /// Returns details of projects, issue types within projects, and, when requested, the create screen fields for each issue type for the user. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  Deprecated, see [Create Issue Meta Endpoint Deprecation Notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-1304).  The request can be restricted to specific projects or issue types using the query parameters. The response will contain information for the valid projects, issue types, or project and issue type combinations requested. Note that invalid project, issue type, or project and issue type combinations do not generate errors.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIds">List of project IDs. This parameter accepts a comma-separated list. Multiple project IDs can also be provided using an ampersand-separated list. For example, &#x60;projectIds&#x3D;10000,10001&amp;projectIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;projectKeys&#x60;. (optional)</param>
        /// <param name="projectKeys">List of project keys. This parameter accepts a comma-separated list. Multiple project keys can also be provided using an ampersand-separated list. For example, &#x60;projectKeys&#x3D;proj1,proj2&amp;projectKeys&#x3D;proj3&#x60;. This parameter may be provided with &#x60;projectIds&#x60;. (optional)</param>
        /// <param name="issuetypeIds">List of issue type IDs. This parameter accepts a comma-separated list. Multiple issue type IDs can also be provided using an ampersand-separated list. For example, &#x60;issuetypeIds&#x3D;10000,10001&amp;issuetypeIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;issuetypeNames&#x60;. (optional)</param>
        /// <param name="issuetypeNames">List of issue type names. This parameter accepts a comma-separated list. Multiple issue type names can also be provided using an ampersand-separated list. For example, &#x60;issuetypeNames&#x3D;name1,name2&amp;issuetypeNames&#x3D;name3&#x60;. This parameter may be provided with &#x60;issuetypeIds&#x60;. (optional)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about issue metadata in the response. This parameter accepts &#x60;projects.issuetypes.fields&#x60;, which returns information about the fields in the issue creation screen for each issue type. Fields hidden from the screen are not returned. Use the information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post). (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueCreateMetadata</returns>
        [Obsolete]
        IssueCreateMetadata GetCreateIssueMeta(List<string>? projectIds = default(List<string>?), List<string>? projectKeys = default(List<string>?), List<string>? issuetypeIds = default(List<string>?), List<string>? issuetypeNames = default(List<string>?), string? expand = default(string?), int operationIndex = 0);

        /// <summary>
        /// Get create issue metadata
        /// </summary>
        /// <remarks>
        /// Returns details of projects, issue types within projects, and, when requested, the create screen fields for each issue type for the user. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  Deprecated, see [Create Issue Meta Endpoint Deprecation Notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-1304).  The request can be restricted to specific projects or issue types using the query parameters. The response will contain information for the valid projects, issue types, or project and issue type combinations requested. Note that invalid project, issue type, or project and issue type combinations do not generate errors.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIds">List of project IDs. This parameter accepts a comma-separated list. Multiple project IDs can also be provided using an ampersand-separated list. For example, &#x60;projectIds&#x3D;10000,10001&amp;projectIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;projectKeys&#x60;. (optional)</param>
        /// <param name="projectKeys">List of project keys. This parameter accepts a comma-separated list. Multiple project keys can also be provided using an ampersand-separated list. For example, &#x60;projectKeys&#x3D;proj1,proj2&amp;projectKeys&#x3D;proj3&#x60;. This parameter may be provided with &#x60;projectIds&#x60;. (optional)</param>
        /// <param name="issuetypeIds">List of issue type IDs. This parameter accepts a comma-separated list. Multiple issue type IDs can also be provided using an ampersand-separated list. For example, &#x60;issuetypeIds&#x3D;10000,10001&amp;issuetypeIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;issuetypeNames&#x60;. (optional)</param>
        /// <param name="issuetypeNames">List of issue type names. This parameter accepts a comma-separated list. Multiple issue type names can also be provided using an ampersand-separated list. For example, &#x60;issuetypeNames&#x3D;name1,name2&amp;issuetypeNames&#x3D;name3&#x60;. This parameter may be provided with &#x60;issuetypeIds&#x60;. (optional)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about issue metadata in the response. This parameter accepts &#x60;projects.issuetypes.fields&#x60;, which returns information about the fields in the issue creation screen for each issue type. Fields hidden from the screen are not returned. Use the information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post). (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueCreateMetadata</returns>
        [Obsolete]
        ApiResponse<IssueCreateMetadata> GetCreateIssueMetaWithHttpInfo(List<string>? projectIds = default(List<string>?), List<string>? projectKeys = default(List<string>?), List<string>? issuetypeIds = default(List<string>?), List<string>? issuetypeNames = default(List<string>?), string? expand = default(string?), int operationIndex = 0);
        /// <summary>
        /// Get create field metadata for a project and issue type id
        /// </summary>
        /// <remarks>
        /// Returns a page of field metadata for a specified project and issuetype id. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="issueTypeId">The issuetype ID.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageOfCreateMetaIssueTypeWithField</returns>
        PageOfCreateMetaIssueTypeWithField GetCreateIssueMetaIssueTypeId(string projectIdOrKey, string issueTypeId, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0);

        /// <summary>
        /// Get create field metadata for a project and issue type id
        /// </summary>
        /// <remarks>
        /// Returns a page of field metadata for a specified project and issuetype id. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="issueTypeId">The issuetype ID.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageOfCreateMetaIssueTypeWithField</returns>
        ApiResponse<PageOfCreateMetaIssueTypeWithField> GetCreateIssueMetaIssueTypeIdWithHttpInfo(string projectIdOrKey, string issueTypeId, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0);
        /// <summary>
        /// Get create metadata issue types for a project
        /// </summary>
        /// <remarks>
        /// Returns a page of issue type metadata for a specified project. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageOfCreateMetaIssueTypes</returns>
        PageOfCreateMetaIssueTypes GetCreateIssueMetaIssueTypes(string projectIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0);

        /// <summary>
        /// Get create metadata issue types for a project
        /// </summary>
        /// <remarks>
        /// Returns a page of issue type metadata for a specified project. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageOfCreateMetaIssueTypes</returns>
        ApiResponse<PageOfCreateMetaIssueTypes> GetCreateIssueMetaIssueTypesWithHttpInfo(string projectIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0);
        /// <summary>
        /// Get edit issue metadata
        /// </summary>
        /// <remarks>
        /// Returns the edit screen fields for an issue that are visible to and editable by the user. Use the information to populate the requests in [Edit issue](#api-rest-api-2-issue-issueIdOrKey-put).  This endpoint will check for these conditions:  1.  Field is available on a field screen - through screen, screen scheme, issue type screen scheme, and issue type scheme configuration. &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 2.  Field is visible in the [field configuration](https://support.atlassian.com/jira-cloud-administration/docs/change-a-field-configuration/). &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 3.  Field is shown on the issue: each field has different conditions here. For example: Attachment field only shows if attachments are enabled. Assignee only shows if user has permissions to assign the issue. 4.  If a field is custom then it must have valid custom field context, applicable for its project and issue type. All system fields are assumed to have context in all projects and all issue types. 5.  Issue has a project, issue type, and status defined. 6.  Issue is assigned to a valid workflow, and the current status has assigned a workflow step. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 7.  The current workflow step is editable. This is true by default, but [can be disabled by setting](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) the &#x60;jira.issue.editable&#x60; property to &#x60;false&#x60;. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 8.  User has [Edit issues permission](https://support.atlassian.com/jira-cloud-administration/docs/permissions-for-company-managed-projects/). 9.  Workflow permissions allow editing a field. This is true by default but [can be modified](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) using &#x60;jira.permission.*&#x60; workflow properties.  Fields hidden using [Issue layout settings page](https://support.atlassian.com/jira-software-cloud/docs/configure-field-layout-in-the-issue-view/) remain editable.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can return additional details using:   *  &#x60;overrideScreenSecurity&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if fields are available through screens, and field configuration (conditions 1. and 2. from the list above).  *  &#x60;overrideEditableFlag&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if workflow is present and if the current step is editable (conditions 6. and 7. from the list above).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  Note: For any fields to be editable the user must have the *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="overrideScreenSecurity">Whether hidden fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether non-editable fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueUpdateMetadata</returns>
        IssueUpdateMetadata GetEditIssueMeta(string issueIdOrKey, bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), int operationIndex = 0);

        /// <summary>
        /// Get edit issue metadata
        /// </summary>
        /// <remarks>
        /// Returns the edit screen fields for an issue that are visible to and editable by the user. Use the information to populate the requests in [Edit issue](#api-rest-api-2-issue-issueIdOrKey-put).  This endpoint will check for these conditions:  1.  Field is available on a field screen - through screen, screen scheme, issue type screen scheme, and issue type scheme configuration. &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 2.  Field is visible in the [field configuration](https://support.atlassian.com/jira-cloud-administration/docs/change-a-field-configuration/). &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 3.  Field is shown on the issue: each field has different conditions here. For example: Attachment field only shows if attachments are enabled. Assignee only shows if user has permissions to assign the issue. 4.  If a field is custom then it must have valid custom field context, applicable for its project and issue type. All system fields are assumed to have context in all projects and all issue types. 5.  Issue has a project, issue type, and status defined. 6.  Issue is assigned to a valid workflow, and the current status has assigned a workflow step. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 7.  The current workflow step is editable. This is true by default, but [can be disabled by setting](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) the &#x60;jira.issue.editable&#x60; property to &#x60;false&#x60;. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 8.  User has [Edit issues permission](https://support.atlassian.com/jira-cloud-administration/docs/permissions-for-company-managed-projects/). 9.  Workflow permissions allow editing a field. This is true by default but [can be modified](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) using &#x60;jira.permission.*&#x60; workflow properties.  Fields hidden using [Issue layout settings page](https://support.atlassian.com/jira-software-cloud/docs/configure-field-layout-in-the-issue-view/) remain editable.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can return additional details using:   *  &#x60;overrideScreenSecurity&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if fields are available through screens, and field configuration (conditions 1. and 2. from the list above).  *  &#x60;overrideEditableFlag&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if workflow is present and if the current step is editable (conditions 6. and 7. from the list above).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  Note: For any fields to be editable the user must have the *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="overrideScreenSecurity">Whether hidden fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether non-editable fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueUpdateMetadata</returns>
        ApiResponse<IssueUpdateMetadata> GetEditIssueMetaWithHttpInfo(string issueIdOrKey, bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), int operationIndex = 0);
        /// <summary>
        /// Get events
        /// </summary>
        /// <remarks>
        /// Returns all issue events.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;IssueEvent&gt;</returns>
        List<IssueEvent> GetEvents(int operationIndex = 0);

        /// <summary>
        /// Get events
        /// </summary>
        /// <remarks>
        /// Returns all issue events.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;IssueEvent&gt;</returns>
        ApiResponse<List<IssueEvent>> GetEventsWithHttpInfo(int operationIndex = 0);
        /// <summary>
        /// Get issue
        /// </summary>
        /// <remarks>
        /// Returns the details for an issue.  The issue is identified by its ID or key, however, if the identifier doesn&#39;t match an issue, a case-insensitive search and check for moved issues is performed. If a matching issue is found its details are returned, a 302 or other redirect is **not** returned. The issue key returned in the response is the key of the issue found.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="fields">A list of fields to return for the issue. This parameter accepts a comma-separated list. Use it to retrieve a subset of fields. Allowed values:   *  &#x60;*all&#x60; Returns all fields.  *  &#x60;*navigable&#x60; Returns navigable fields.  *  Any issue field, prefixed with a minus to exclude.  Examples:   *  &#x60;summary,comment&#x60; Returns only the summary and comments fields.  *  &#x60;-description&#x60; Returns all (default) fields except description.  *  &#x60;*navigable,-comment&#x60; Returns all navigable fields except comment.  This parameter may be specified multiple times. For example, &#x60;fields&#x3D;field1,field2&amp; fields&#x3D;field3&#x60;.  Note: All fields are returned by default. This differs from [Search for issues using JQL (GET)](#api-rest-api-2-search-get) and [Search for issues using JQL (POST)](#api-rest-api-2-search-post) where the default is all navigable fields. (optional)</param>
        /// <param name="fieldsByKeys">Whether fields in &#x60;fields&#x60; are referenced by keys rather than IDs. This parameter is useful where fields have been added by a connect app and a field&#39;s key may differ from its ID. (optional, default to false)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about the issues in the response. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;renderedFields&#x60; Returns field values rendered in HTML format.  *  &#x60;names&#x60; Returns the display name of each field.  *  &#x60;schema&#x60; Returns the schema describing a field type.  *  &#x60;transitions&#x60; Returns all possible transitions for the issue.  *  &#x60;editmeta&#x60; Returns information about how each field can be edited.  *  &#x60;changelog&#x60; Returns a list of recent updates to an issue, sorted by date, starting from the most recent.  *  &#x60;versionedRepresentations&#x60; Returns a JSON array for each version of a field&#39;s value, with the highest number representing the most recent version. Note: When included in the request, the &#x60;fields&#x60; parameter is ignored. (optional)</param>
        /// <param name="properties">A list of issue properties to return for the issue. This parameter accepts a comma-separated list. Allowed values:   *  &#x60;*all&#x60; Returns all issue properties.  *  Any issue property key, prefixed with a minus to exclude.  Examples:   *  &#x60;*all&#x60; Returns all properties.  *  &#x60;*all,-prop1&#x60; Returns all properties except &#x60;prop1&#x60;.  *  &#x60;prop1,prop2&#x60; Returns &#x60;prop1&#x60; and &#x60;prop2&#x60; properties.  This parameter may be specified multiple times. For example, &#x60;properties&#x3D;prop1,prop2&amp; properties&#x3D;prop3&#x60;. (optional)</param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. This also populates the [JQL issues search](#api-rest-api-2-search-get) &#x60;lastViewed&#x60; field. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueBean</returns>
        IssueBean GetIssue(string issueIdOrKey, List<string>? fields = default(List<string>?), bool? fieldsByKeys = default(bool?), string? expand = default(string?), List<string>? properties = default(List<string>?), bool? updateHistory = default(bool?), int operationIndex = 0);

        /// <summary>
        /// Get issue
        /// </summary>
        /// <remarks>
        /// Returns the details for an issue.  The issue is identified by its ID or key, however, if the identifier doesn&#39;t match an issue, a case-insensitive search and check for moved issues is performed. If a matching issue is found its details are returned, a 302 or other redirect is **not** returned. The issue key returned in the response is the key of the issue found.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="fields">A list of fields to return for the issue. This parameter accepts a comma-separated list. Use it to retrieve a subset of fields. Allowed values:   *  &#x60;*all&#x60; Returns all fields.  *  &#x60;*navigable&#x60; Returns navigable fields.  *  Any issue field, prefixed with a minus to exclude.  Examples:   *  &#x60;summary,comment&#x60; Returns only the summary and comments fields.  *  &#x60;-description&#x60; Returns all (default) fields except description.  *  &#x60;*navigable,-comment&#x60; Returns all navigable fields except comment.  This parameter may be specified multiple times. For example, &#x60;fields&#x3D;field1,field2&amp; fields&#x3D;field3&#x60;.  Note: All fields are returned by default. This differs from [Search for issues using JQL (GET)](#api-rest-api-2-search-get) and [Search for issues using JQL (POST)](#api-rest-api-2-search-post) where the default is all navigable fields. (optional)</param>
        /// <param name="fieldsByKeys">Whether fields in &#x60;fields&#x60; are referenced by keys rather than IDs. This parameter is useful where fields have been added by a connect app and a field&#39;s key may differ from its ID. (optional, default to false)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about the issues in the response. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;renderedFields&#x60; Returns field values rendered in HTML format.  *  &#x60;names&#x60; Returns the display name of each field.  *  &#x60;schema&#x60; Returns the schema describing a field type.  *  &#x60;transitions&#x60; Returns all possible transitions for the issue.  *  &#x60;editmeta&#x60; Returns information about how each field can be edited.  *  &#x60;changelog&#x60; Returns a list of recent updates to an issue, sorted by date, starting from the most recent.  *  &#x60;versionedRepresentations&#x60; Returns a JSON array for each version of a field&#39;s value, with the highest number representing the most recent version. Note: When included in the request, the &#x60;fields&#x60; parameter is ignored. (optional)</param>
        /// <param name="properties">A list of issue properties to return for the issue. This parameter accepts a comma-separated list. Allowed values:   *  &#x60;*all&#x60; Returns all issue properties.  *  Any issue property key, prefixed with a minus to exclude.  Examples:   *  &#x60;*all&#x60; Returns all properties.  *  &#x60;*all,-prop1&#x60; Returns all properties except &#x60;prop1&#x60;.  *  &#x60;prop1,prop2&#x60; Returns &#x60;prop1&#x60; and &#x60;prop2&#x60; properties.  This parameter may be specified multiple times. For example, &#x60;properties&#x3D;prop1,prop2&amp; properties&#x3D;prop3&#x60;. (optional)</param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. This also populates the [JQL issues search](#api-rest-api-2-search-get) &#x60;lastViewed&#x60; field. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueBean</returns>
        ApiResponse<IssueBean> GetIssueWithHttpInfo(string issueIdOrKey, List<string>? fields = default(List<string>?), bool? fieldsByKeys = default(bool?), string? expand = default(string?), List<string>? properties = default(List<string>?), bool? updateHistory = default(bool?), int operationIndex = 0);
        /// <summary>
        /// Get transitions
        /// </summary>
        /// <remarks>
        /// Returns either all transitions or a transition that can be performed by the user on an issue, based on the issue&#39;s status.  Note, if a request is made for a transition that does not exist or cannot be performed on the issue, given its status, the response will return any empty transitions list.  This operation can be accessed anonymously.  **[Permissions](#permissions) required: A list or transition is returned only when the user has:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  However, if the user does not have the *Transition issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) the response will not list any transitions.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about transitions in the response. This parameter accepts &#x60;transitions.fields&#x60;, which returns information about the fields in the transition screen for each transition. Fields hidden from the screen are not returned. Use this information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Transition issue](#api-rest-api-2-issue-issueIdOrKey-transitions-post). (optional)</param>
        /// <param name="transitionId">The ID of the transition. (optional)</param>
        /// <param name="skipRemoteOnlyCondition">Whether transitions with the condition *Hide From User Condition* are included in the response. (optional, default to false)</param>
        /// <param name="includeUnavailableTransitions">Whether details of transitions that fail a condition are included in the response (optional, default to false)</param>
        /// <param name="sortByOpsBarAndStatus">Whether the transitions are sorted by ops-bar sequence value first then category order (Todo, In Progress, Done) or only by ops-bar sequence value. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Transitions</returns>
        Transitions GetTransitions(string issueIdOrKey, string? expand = default(string?), string? transitionId = default(string?), bool? skipRemoteOnlyCondition = default(bool?), bool? includeUnavailableTransitions = default(bool?), bool? sortByOpsBarAndStatus = default(bool?), int operationIndex = 0);

        /// <summary>
        /// Get transitions
        /// </summary>
        /// <remarks>
        /// Returns either all transitions or a transition that can be performed by the user on an issue, based on the issue&#39;s status.  Note, if a request is made for a transition that does not exist or cannot be performed on the issue, given its status, the response will return any empty transitions list.  This operation can be accessed anonymously.  **[Permissions](#permissions) required: A list or transition is returned only when the user has:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  However, if the user does not have the *Transition issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) the response will not list any transitions.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about transitions in the response. This parameter accepts &#x60;transitions.fields&#x60;, which returns information about the fields in the transition screen for each transition. Fields hidden from the screen are not returned. Use this information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Transition issue](#api-rest-api-2-issue-issueIdOrKey-transitions-post). (optional)</param>
        /// <param name="transitionId">The ID of the transition. (optional)</param>
        /// <param name="skipRemoteOnlyCondition">Whether transitions with the condition *Hide From User Condition* are included in the response. (optional, default to false)</param>
        /// <param name="includeUnavailableTransitions">Whether details of transitions that fail a condition are included in the response (optional, default to false)</param>
        /// <param name="sortByOpsBarAndStatus">Whether the transitions are sorted by ops-bar sequence value first then category order (Todo, In Progress, Done) or only by ops-bar sequence value. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Transitions</returns>
        ApiResponse<Transitions> GetTransitionsWithHttpInfo(string issueIdOrKey, string? expand = default(string?), string? transitionId = default(string?), bool? skipRemoteOnlyCondition = default(bool?), bool? includeUnavailableTransitions = default(bool?), bool? sortByOpsBarAndStatus = default(bool?), int operationIndex = 0);
        /// <summary>
        /// Send notification for issue
        /// </summary>
        /// <remarks>
        /// Creates an email notification for an issue and adds it to the mail queue.  **[Permissions](#permissions) required:**   *  *Browse Projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">ID or key of the issue that the notification is sent for.</param>
        /// <param name="notification">The request object for the notification and recipients.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Object</returns>
        Object Notify(string issueIdOrKey, Notification notification, int operationIndex = 0);

        /// <summary>
        /// Send notification for issue
        /// </summary>
        /// <remarks>
        /// Creates an email notification for an issue and adds it to the mail queue.  **[Permissions](#permissions) required:**   *  *Browse Projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">ID or key of the issue that the notification is sent for.</param>
        /// <param name="notification">The request object for the notification and recipients.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object</returns>
        ApiResponse<Object> NotifyWithHttpInfo(string issueIdOrKey, Notification notification, int operationIndex = 0);
        /// <summary>
        /// Unarchive issue(s) by issue keys/ID
        /// </summary>
        /// <remarks>
        /// Enables admins to unarchive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) unarchived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t unarchive subtasks directly, only through their parent issues  *  you can only unarchive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be unarchived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueArchivalSyncResponse</returns>
        IssueArchivalSyncResponse UnarchiveIssues(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0);

        /// <summary>
        /// Unarchive issue(s) by issue keys/ID
        /// </summary>
        /// <remarks>
        /// Enables admins to unarchive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) unarchived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t unarchive subtasks directly, only through their parent issues  *  you can only unarchive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be unarchived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueArchivalSyncResponse</returns>
        ApiResponse<IssueArchivalSyncResponse> UnarchiveIssuesWithHttpInfo(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0);
        #endregion Synchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IIssuesApiAsync : IApiAccessor
    {
        #region Asynchronous Operations
        /// <summary>
        /// Archive issue(s) by issue ID/key
        /// </summary>
        /// <remarks>
        /// Enables admins to archive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) archived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be archived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueArchivalSyncResponse</returns>
        System.Threading.Tasks.Task<IssueArchivalSyncResponse> ArchiveIssuesAsync(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Archive issue(s) by issue ID/key
        /// </summary>
        /// <remarks>
        /// Enables admins to archive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) archived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be archived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueArchivalSyncResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<IssueArchivalSyncResponse>> ArchiveIssuesWithHttpInfoAsync(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Archive issue(s) by JQL
        /// </summary>
        /// <remarks>
        /// Enables admins to archive up to 100,000 issues in a single request using JQL, returning the URL to check the status of the submitted request.  You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) and [cancel task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-cancel-post) APIs to manage the request.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request per jira instance can be active at any given time.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveIssueAsyncRequest">A JQL query specifying the issues to archive. Note that subtasks can only be archived through their parent issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        System.Threading.Tasks.Task<string> ArchiveIssuesAsyncAsync(ArchiveIssueAsyncRequest archiveIssueAsyncRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Archive issue(s) by JQL
        /// </summary>
        /// <remarks>
        /// Enables admins to archive up to 100,000 issues in a single request using JQL, returning the URL to check the status of the submitted request.  You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) and [cancel task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-cancel-post) APIs to manage the request.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request per jira instance can be active at any given time.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveIssueAsyncRequest">A JQL query specifying the issues to archive. Note that subtasks can only be archived through their parent issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        System.Threading.Tasks.Task<ApiResponse<string>> ArchiveIssuesAsyncWithHttpInfoAsync(ArchiveIssueAsyncRequest archiveIssueAsyncRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Assign issue
        /// </summary>
        /// <remarks>
        /// Assigns an issue to a user. Use this operation when the calling user does not have the *Edit Issues* permission but has the *Assign issue* permission for the project that the issue is in.  If &#x60;name&#x60; or &#x60;accountId&#x60; is set to:   *  &#x60;\&quot;-1\&quot;&#x60;, the issue is assigned to the default assignee for the project.  *  &#x60;null&#x60;, the issue is set to unassigned.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse Projects* and *Assign Issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue to be assigned.</param>
        /// <param name="user">The request object with the user that the issue is assigned to.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Object</returns>
        System.Threading.Tasks.Task<Object> AssignIssueAsync(string issueIdOrKey, User user, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Assign issue
        /// </summary>
        /// <remarks>
        /// Assigns an issue to a user. Use this operation when the calling user does not have the *Edit Issues* permission but has the *Assign issue* permission for the project that the issue is in.  If &#x60;name&#x60; or &#x60;accountId&#x60; is set to:   *  &#x60;\&quot;-1\&quot;&#x60;, the issue is assigned to the default assignee for the project.  *  &#x60;null&#x60;, the issue is set to unassigned.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse Projects* and *Assign Issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue to be assigned.</param>
        /// <param name="user">The request object with the user that the issue is assigned to.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> AssignIssueWithHttpInfoAsync(string issueIdOrKey, User user, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Create issue
        /// </summary>
        /// <remarks>
        /// Creates an issue or, where the option to create subtasks is enabled in Jira, a subtask. A transition may be applied, to move the issue or subtask to a workflow step other than the default start step, and issue properties set.  The content of the issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issue&#39;s create screen.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which the issue or subtask is created.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. When provided, the issue type and request type are added to the user&#39;s history for a project. These values are then used to provide defaults on the issue create screen. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreatedIssue</returns>
        System.Threading.Tasks.Task<CreatedIssue> CreateIssueAsync(IssueUpdateDetails issueUpdateDetails, bool? updateHistory = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Create issue
        /// </summary>
        /// <remarks>
        /// Creates an issue or, where the option to create subtasks is enabled in Jira, a subtask. A transition may be applied, to move the issue or subtask to a workflow step other than the default start step, and issue properties set.  The content of the issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issue&#39;s create screen.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which the issue or subtask is created.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. When provided, the issue type and request type are added to the user&#39;s history for a project. These values are then used to provide defaults on the issue create screen. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreatedIssue)</returns>
        System.Threading.Tasks.Task<ApiResponse<CreatedIssue>> CreateIssueWithHttpInfoAsync(IssueUpdateDetails issueUpdateDetails, bool? updateHistory = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Bulk create issue
        /// </summary>
        /// <remarks>
        /// Creates upto **50** issues and, where the option to create subtasks is enabled in Jira, subtasks. Transitions may be applied, to move the issues or subtasks to a workflow step other than the default start step, and issue properties set.  The content of each issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issues&#39; create screens.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; the must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which each issue or subtask is created.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuesUpdateBean"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreatedIssues</returns>
        System.Threading.Tasks.Task<CreatedIssues> CreateIssuesAsync(IssuesUpdateBean issuesUpdateBean, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Bulk create issue
        /// </summary>
        /// <remarks>
        /// Creates upto **50** issues and, where the option to create subtasks is enabled in Jira, subtasks. Transitions may be applied, to move the issues or subtasks to a workflow step other than the default start step, and issue properties set.  The content of each issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issues&#39; create screens.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; the must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which each issue or subtask is created.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuesUpdateBean"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreatedIssues)</returns>
        System.Threading.Tasks.Task<ApiResponse<CreatedIssues>> CreateIssuesWithHttpInfoAsync(IssuesUpdateBean issuesUpdateBean, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Delete issue
        /// </summary>
        /// <remarks>
        /// Deletes an issue.  An issue cannot be deleted if it has one or more subtasks. To delete an issue with subtasks, set &#x60;deleteSubtasks&#x60;. This causes the issue&#39;s subtasks to be deleted with the issue.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Delete issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="deleteSubtasks">Whether the issue&#39;s subtasks are deleted when the issue is deleted. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        System.Threading.Tasks.Task DeleteIssueAsync(string issueIdOrKey, string? deleteSubtasks = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Delete issue
        /// </summary>
        /// <remarks>
        /// Deletes an issue.  An issue cannot be deleted if it has one or more subtasks. To delete an issue with subtasks, set &#x60;deleteSubtasks&#x60;. This causes the issue&#39;s subtasks to be deleted with the issue.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Delete issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="deleteSubtasks">Whether the issue&#39;s subtasks are deleted when the issue is deleted. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DeleteIssueWithHttpInfoAsync(string issueIdOrKey, string? deleteSubtasks = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Transition issue
        /// </summary>
        /// <remarks>
        /// Performs an issue transition and, if the transition has a screen, updates the fields from the transition screen.  sortByCategory To update the fields on the transition screen, specify the fields in the &#x60;fields&#x60; or &#x60;update&#x60; parameters in the request body. Get details about the fields using [ Get transitions](#api-rest-api-2-issue-issueIdOrKey-transitions-get) with the &#x60;transitions.fields&#x60; expand.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Transition issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Object</returns>
        System.Threading.Tasks.Task<Object> DoTransitionAsync(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Transition issue
        /// </summary>
        /// <remarks>
        /// Performs an issue transition and, if the transition has a screen, updates the fields from the transition screen.  sortByCategory To update the fields on the transition screen, specify the fields in the &#x60;fields&#x60; or &#x60;update&#x60; parameters in the request body. Get details about the fields using [ Get transitions](#api-rest-api-2-issue-issueIdOrKey-transitions-get) with the &#x60;transitions.fields&#x60; expand.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Transition issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> DoTransitionWithHttpInfoAsync(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Edit issue
        /// </summary>
        /// <remarks>
        /// Edits an issue. Issue properties may be updated as part of the edit. Please note that issue transition will be ignored as it is not supported yet.  The edits to the issue&#39;s fields are defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be edited are determined using [ Get edit issue metadata](#api-rest-api-2-issue-issueIdOrKey-editmeta-get).  The parent field may be set by key or ID. For standard issue types, the parent may be removed by setting &#x60;update.parent.set.none&#x60; to *true*.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can override the screen security configuration using &#x60;overrideScreenSecurity&#x60; and &#x60;overrideEditableFlag&#x60;.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="notifyUsers">Whether a notification email about the issue update is sent to all watchers. To disable the notification, administer Jira or administer project permissions are required. If the user doesn&#39;t have the necessary permission the request is ignored. (optional, default to true)</param>
        /// <param name="overrideScreenSecurity">Whether screen security is overridden to enable hidden fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="returnIssue">Whether the response should contain the issue with fields edited in this request. The returned issue will have the same format as in the [Get issue API](#api-rest-api-3-issue-issueidorkey-get). (optional, default to false)</param>
        /// <param name="expand">The Get issue API expand parameter to use in the response if the &#x60;returnIssue&#x60; parameter is &#x60;true&#x60;. (optional, default to &quot;&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Object</returns>
        System.Threading.Tasks.Task<Object> EditIssueAsync(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, bool? notifyUsers = default(bool?), bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), bool? returnIssue = default(bool?), string? expand = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Edit issue
        /// </summary>
        /// <remarks>
        /// Edits an issue. Issue properties may be updated as part of the edit. Please note that issue transition will be ignored as it is not supported yet.  The edits to the issue&#39;s fields are defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be edited are determined using [ Get edit issue metadata](#api-rest-api-2-issue-issueIdOrKey-editmeta-get).  The parent field may be set by key or ID. For standard issue types, the parent may be removed by setting &#x60;update.parent.set.none&#x60; to *true*.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can override the screen security configuration using &#x60;overrideScreenSecurity&#x60; and &#x60;overrideEditableFlag&#x60;.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="notifyUsers">Whether a notification email about the issue update is sent to all watchers. To disable the notification, administer Jira or administer project permissions are required. If the user doesn&#39;t have the necessary permission the request is ignored. (optional, default to true)</param>
        /// <param name="overrideScreenSecurity">Whether screen security is overridden to enable hidden fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="returnIssue">Whether the response should contain the issue with fields edited in this request. The returned issue will have the same format as in the [Get issue API](#api-rest-api-3-issue-issueidorkey-get). (optional, default to false)</param>
        /// <param name="expand">The Get issue API expand parameter to use in the response if the &#x60;returnIssue&#x60; parameter is &#x60;true&#x60;. (optional, default to &quot;&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> EditIssueWithHttpInfoAsync(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, bool? notifyUsers = default(bool?), bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), bool? returnIssue = default(bool?), string? expand = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Export archived issue(s)
        /// </summary>
        /// <remarks>
        /// Enables admins to retrieve details of all archived issues. Upon a successful request, the admin who submitted it will receive an email with a link to download a CSV file with the issue details.  Note that this API only exports the values of system fields and archival-specific fields (&#x60;ArchivedBy&#x60; and &#x60;ArchivedDate&#x60;). Custom fields aren&#39;t supported.  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request can be active at any given time.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archivedIssuesFilterRequest">You can filter the issues in your request by the &#x60;projects&#x60;, &#x60;archivedBy&#x60;, &#x60;archivedDate&#x60;, &#x60;issueTypes&#x60;, and &#x60;reporters&#x60; fields. All filters are optional. If you don&#39;t provide any filters, you&#39;ll get a list of up to one million archived issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ExportArchivedIssuesTaskProgressResponse</returns>
        System.Threading.Tasks.Task<ExportArchivedIssuesTaskProgressResponse> ExportArchivedIssuesAsync(ArchivedIssuesFilterRequest archivedIssuesFilterRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Export archived issue(s)
        /// </summary>
        /// <remarks>
        /// Enables admins to retrieve details of all archived issues. Upon a successful request, the admin who submitted it will receive an email with a link to download a CSV file with the issue details.  Note that this API only exports the values of system fields and archival-specific fields (&#x60;ArchivedBy&#x60; and &#x60;ArchivedDate&#x60;). Custom fields aren&#39;t supported.  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request can be active at any given time.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archivedIssuesFilterRequest">You can filter the issues in your request by the &#x60;projects&#x60;, &#x60;archivedBy&#x60;, &#x60;archivedDate&#x60;, &#x60;issueTypes&#x60;, and &#x60;reporters&#x60; fields. All filters are optional. If you don&#39;t provide any filters, you&#39;ll get a list of up to one million archived issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ExportArchivedIssuesTaskProgressResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<ExportArchivedIssuesTaskProgressResponse>> ExportArchivedIssuesWithHttpInfoAsync(ArchivedIssuesFilterRequest archivedIssuesFilterRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get changelogs
        /// </summary>
        /// <remarks>
        /// Returns a [paginated](#pagination) list of all changelogs for an issue sorted by date, starting from the oldest.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 100)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageBeanChangelog</returns>
        System.Threading.Tasks.Task<PageBeanChangelog> GetChangeLogsAsync(string issueIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get changelogs
        /// </summary>
        /// <remarks>
        /// Returns a [paginated](#pagination) list of all changelogs for an issue sorted by date, starting from the oldest.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 100)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageBeanChangelog)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageBeanChangelog>> GetChangeLogsWithHttpInfoAsync(string issueIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get changelogs by IDs
        /// </summary>
        /// <remarks>
        /// Returns changelogs for an issue specified by a list of changelog IDs.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueChangelogIds"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageOfChangelogs</returns>
        System.Threading.Tasks.Task<PageOfChangelogs> GetChangeLogsByIdsAsync(string issueIdOrKey, IssueChangelogIds issueChangelogIds, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get changelogs by IDs
        /// </summary>
        /// <remarks>
        /// Returns changelogs for an issue specified by a list of changelog IDs.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueChangelogIds"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageOfChangelogs)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageOfChangelogs>> GetChangeLogsByIdsWithHttpInfoAsync(string issueIdOrKey, IssueChangelogIds issueChangelogIds, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get create issue metadata
        /// </summary>
        /// <remarks>
        /// Returns details of projects, issue types within projects, and, when requested, the create screen fields for each issue type for the user. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  Deprecated, see [Create Issue Meta Endpoint Deprecation Notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-1304).  The request can be restricted to specific projects or issue types using the query parameters. The response will contain information for the valid projects, issue types, or project and issue type combinations requested. Note that invalid project, issue type, or project and issue type combinations do not generate errors.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIds">List of project IDs. This parameter accepts a comma-separated list. Multiple project IDs can also be provided using an ampersand-separated list. For example, &#x60;projectIds&#x3D;10000,10001&amp;projectIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;projectKeys&#x60;. (optional)</param>
        /// <param name="projectKeys">List of project keys. This parameter accepts a comma-separated list. Multiple project keys can also be provided using an ampersand-separated list. For example, &#x60;projectKeys&#x3D;proj1,proj2&amp;projectKeys&#x3D;proj3&#x60;. This parameter may be provided with &#x60;projectIds&#x60;. (optional)</param>
        /// <param name="issuetypeIds">List of issue type IDs. This parameter accepts a comma-separated list. Multiple issue type IDs can also be provided using an ampersand-separated list. For example, &#x60;issuetypeIds&#x3D;10000,10001&amp;issuetypeIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;issuetypeNames&#x60;. (optional)</param>
        /// <param name="issuetypeNames">List of issue type names. This parameter accepts a comma-separated list. Multiple issue type names can also be provided using an ampersand-separated list. For example, &#x60;issuetypeNames&#x3D;name1,name2&amp;issuetypeNames&#x3D;name3&#x60;. This parameter may be provided with &#x60;issuetypeIds&#x60;. (optional)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about issue metadata in the response. This parameter accepts &#x60;projects.issuetypes.fields&#x60;, which returns information about the fields in the issue creation screen for each issue type. Fields hidden from the screen are not returned. Use the information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post). (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueCreateMetadata</returns>
        [Obsolete]
        System.Threading.Tasks.Task<IssueCreateMetadata> GetCreateIssueMetaAsync(List<string>? projectIds = default(List<string>?), List<string>? projectKeys = default(List<string>?), List<string>? issuetypeIds = default(List<string>?), List<string>? issuetypeNames = default(List<string>?), string? expand = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get create issue metadata
        /// </summary>
        /// <remarks>
        /// Returns details of projects, issue types within projects, and, when requested, the create screen fields for each issue type for the user. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  Deprecated, see [Create Issue Meta Endpoint Deprecation Notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-1304).  The request can be restricted to specific projects or issue types using the query parameters. The response will contain information for the valid projects, issue types, or project and issue type combinations requested. Note that invalid project, issue type, or project and issue type combinations do not generate errors.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIds">List of project IDs. This parameter accepts a comma-separated list. Multiple project IDs can also be provided using an ampersand-separated list. For example, &#x60;projectIds&#x3D;10000,10001&amp;projectIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;projectKeys&#x60;. (optional)</param>
        /// <param name="projectKeys">List of project keys. This parameter accepts a comma-separated list. Multiple project keys can also be provided using an ampersand-separated list. For example, &#x60;projectKeys&#x3D;proj1,proj2&amp;projectKeys&#x3D;proj3&#x60;. This parameter may be provided with &#x60;projectIds&#x60;. (optional)</param>
        /// <param name="issuetypeIds">List of issue type IDs. This parameter accepts a comma-separated list. Multiple issue type IDs can also be provided using an ampersand-separated list. For example, &#x60;issuetypeIds&#x3D;10000,10001&amp;issuetypeIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;issuetypeNames&#x60;. (optional)</param>
        /// <param name="issuetypeNames">List of issue type names. This parameter accepts a comma-separated list. Multiple issue type names can also be provided using an ampersand-separated list. For example, &#x60;issuetypeNames&#x3D;name1,name2&amp;issuetypeNames&#x3D;name3&#x60;. This parameter may be provided with &#x60;issuetypeIds&#x60;. (optional)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about issue metadata in the response. This parameter accepts &#x60;projects.issuetypes.fields&#x60;, which returns information about the fields in the issue creation screen for each issue type. Fields hidden from the screen are not returned. Use the information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post). (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueCreateMetadata)</returns>
        [Obsolete]
        System.Threading.Tasks.Task<ApiResponse<IssueCreateMetadata>> GetCreateIssueMetaWithHttpInfoAsync(List<string>? projectIds = default(List<string>?), List<string>? projectKeys = default(List<string>?), List<string>? issuetypeIds = default(List<string>?), List<string>? issuetypeNames = default(List<string>?), string? expand = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get create field metadata for a project and issue type id
        /// </summary>
        /// <remarks>
        /// Returns a page of field metadata for a specified project and issuetype id. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="issueTypeId">The issuetype ID.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageOfCreateMetaIssueTypeWithField</returns>
        System.Threading.Tasks.Task<PageOfCreateMetaIssueTypeWithField> GetCreateIssueMetaIssueTypeIdAsync(string projectIdOrKey, string issueTypeId, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get create field metadata for a project and issue type id
        /// </summary>
        /// <remarks>
        /// Returns a page of field metadata for a specified project and issuetype id. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="issueTypeId">The issuetype ID.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageOfCreateMetaIssueTypeWithField)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageOfCreateMetaIssueTypeWithField>> GetCreateIssueMetaIssueTypeIdWithHttpInfoAsync(string projectIdOrKey, string issueTypeId, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get create metadata issue types for a project
        /// </summary>
        /// <remarks>
        /// Returns a page of issue type metadata for a specified project. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageOfCreateMetaIssueTypes</returns>
        System.Threading.Tasks.Task<PageOfCreateMetaIssueTypes> GetCreateIssueMetaIssueTypesAsync(string projectIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get create metadata issue types for a project
        /// </summary>
        /// <remarks>
        /// Returns a page of issue type metadata for a specified project. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageOfCreateMetaIssueTypes)</returns>
        System.Threading.Tasks.Task<ApiResponse<PageOfCreateMetaIssueTypes>> GetCreateIssueMetaIssueTypesWithHttpInfoAsync(string projectIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get edit issue metadata
        /// </summary>
        /// <remarks>
        /// Returns the edit screen fields for an issue that are visible to and editable by the user. Use the information to populate the requests in [Edit issue](#api-rest-api-2-issue-issueIdOrKey-put).  This endpoint will check for these conditions:  1.  Field is available on a field screen - through screen, screen scheme, issue type screen scheme, and issue type scheme configuration. &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 2.  Field is visible in the [field configuration](https://support.atlassian.com/jira-cloud-administration/docs/change-a-field-configuration/). &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 3.  Field is shown on the issue: each field has different conditions here. For example: Attachment field only shows if attachments are enabled. Assignee only shows if user has permissions to assign the issue. 4.  If a field is custom then it must have valid custom field context, applicable for its project and issue type. All system fields are assumed to have context in all projects and all issue types. 5.  Issue has a project, issue type, and status defined. 6.  Issue is assigned to a valid workflow, and the current status has assigned a workflow step. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 7.  The current workflow step is editable. This is true by default, but [can be disabled by setting](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) the &#x60;jira.issue.editable&#x60; property to &#x60;false&#x60;. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 8.  User has [Edit issues permission](https://support.atlassian.com/jira-cloud-administration/docs/permissions-for-company-managed-projects/). 9.  Workflow permissions allow editing a field. This is true by default but [can be modified](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) using &#x60;jira.permission.*&#x60; workflow properties.  Fields hidden using [Issue layout settings page](https://support.atlassian.com/jira-software-cloud/docs/configure-field-layout-in-the-issue-view/) remain editable.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can return additional details using:   *  &#x60;overrideScreenSecurity&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if fields are available through screens, and field configuration (conditions 1. and 2. from the list above).  *  &#x60;overrideEditableFlag&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if workflow is present and if the current step is editable (conditions 6. and 7. from the list above).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  Note: For any fields to be editable the user must have the *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="overrideScreenSecurity">Whether hidden fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether non-editable fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueUpdateMetadata</returns>
        System.Threading.Tasks.Task<IssueUpdateMetadata> GetEditIssueMetaAsync(string issueIdOrKey, bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get edit issue metadata
        /// </summary>
        /// <remarks>
        /// Returns the edit screen fields for an issue that are visible to and editable by the user. Use the information to populate the requests in [Edit issue](#api-rest-api-2-issue-issueIdOrKey-put).  This endpoint will check for these conditions:  1.  Field is available on a field screen - through screen, screen scheme, issue type screen scheme, and issue type scheme configuration. &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 2.  Field is visible in the [field configuration](https://support.atlassian.com/jira-cloud-administration/docs/change-a-field-configuration/). &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 3.  Field is shown on the issue: each field has different conditions here. For example: Attachment field only shows if attachments are enabled. Assignee only shows if user has permissions to assign the issue. 4.  If a field is custom then it must have valid custom field context, applicable for its project and issue type. All system fields are assumed to have context in all projects and all issue types. 5.  Issue has a project, issue type, and status defined. 6.  Issue is assigned to a valid workflow, and the current status has assigned a workflow step. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 7.  The current workflow step is editable. This is true by default, but [can be disabled by setting](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) the &#x60;jira.issue.editable&#x60; property to &#x60;false&#x60;. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 8.  User has [Edit issues permission](https://support.atlassian.com/jira-cloud-administration/docs/permissions-for-company-managed-projects/). 9.  Workflow permissions allow editing a field. This is true by default but [can be modified](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) using &#x60;jira.permission.*&#x60; workflow properties.  Fields hidden using [Issue layout settings page](https://support.atlassian.com/jira-software-cloud/docs/configure-field-layout-in-the-issue-view/) remain editable.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can return additional details using:   *  &#x60;overrideScreenSecurity&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if fields are available through screens, and field configuration (conditions 1. and 2. from the list above).  *  &#x60;overrideEditableFlag&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if workflow is present and if the current step is editable (conditions 6. and 7. from the list above).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  Note: For any fields to be editable the user must have the *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="overrideScreenSecurity">Whether hidden fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether non-editable fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueUpdateMetadata)</returns>
        System.Threading.Tasks.Task<ApiResponse<IssueUpdateMetadata>> GetEditIssueMetaWithHttpInfoAsync(string issueIdOrKey, bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get events
        /// </summary>
        /// <remarks>
        /// Returns all issue events.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;IssueEvent&gt;</returns>
        System.Threading.Tasks.Task<List<IssueEvent>> GetEventsAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get events
        /// </summary>
        /// <remarks>
        /// Returns all issue events.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;IssueEvent&gt;)</returns>
        System.Threading.Tasks.Task<ApiResponse<List<IssueEvent>>> GetEventsWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get issue
        /// </summary>
        /// <remarks>
        /// Returns the details for an issue.  The issue is identified by its ID or key, however, if the identifier doesn&#39;t match an issue, a case-insensitive search and check for moved issues is performed. If a matching issue is found its details are returned, a 302 or other redirect is **not** returned. The issue key returned in the response is the key of the issue found.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="fields">A list of fields to return for the issue. This parameter accepts a comma-separated list. Use it to retrieve a subset of fields. Allowed values:   *  &#x60;*all&#x60; Returns all fields.  *  &#x60;*navigable&#x60; Returns navigable fields.  *  Any issue field, prefixed with a minus to exclude.  Examples:   *  &#x60;summary,comment&#x60; Returns only the summary and comments fields.  *  &#x60;-description&#x60; Returns all (default) fields except description.  *  &#x60;*navigable,-comment&#x60; Returns all navigable fields except comment.  This parameter may be specified multiple times. For example, &#x60;fields&#x3D;field1,field2&amp; fields&#x3D;field3&#x60;.  Note: All fields are returned by default. This differs from [Search for issues using JQL (GET)](#api-rest-api-2-search-get) and [Search for issues using JQL (POST)](#api-rest-api-2-search-post) where the default is all navigable fields. (optional)</param>
        /// <param name="fieldsByKeys">Whether fields in &#x60;fields&#x60; are referenced by keys rather than IDs. This parameter is useful where fields have been added by a connect app and a field&#39;s key may differ from its ID. (optional, default to false)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about the issues in the response. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;renderedFields&#x60; Returns field values rendered in HTML format.  *  &#x60;names&#x60; Returns the display name of each field.  *  &#x60;schema&#x60; Returns the schema describing a field type.  *  &#x60;transitions&#x60; Returns all possible transitions for the issue.  *  &#x60;editmeta&#x60; Returns information about how each field can be edited.  *  &#x60;changelog&#x60; Returns a list of recent updates to an issue, sorted by date, starting from the most recent.  *  &#x60;versionedRepresentations&#x60; Returns a JSON array for each version of a field&#39;s value, with the highest number representing the most recent version. Note: When included in the request, the &#x60;fields&#x60; parameter is ignored. (optional)</param>
        /// <param name="properties">A list of issue properties to return for the issue. This parameter accepts a comma-separated list. Allowed values:   *  &#x60;*all&#x60; Returns all issue properties.  *  Any issue property key, prefixed with a minus to exclude.  Examples:   *  &#x60;*all&#x60; Returns all properties.  *  &#x60;*all,-prop1&#x60; Returns all properties except &#x60;prop1&#x60;.  *  &#x60;prop1,prop2&#x60; Returns &#x60;prop1&#x60; and &#x60;prop2&#x60; properties.  This parameter may be specified multiple times. For example, &#x60;properties&#x3D;prop1,prop2&amp; properties&#x3D;prop3&#x60;. (optional)</param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. This also populates the [JQL issues search](#api-rest-api-2-search-get) &#x60;lastViewed&#x60; field. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueBean</returns>
        System.Threading.Tasks.Task<IssueBean> GetIssueAsync(string issueIdOrKey, List<string>? fields = default(List<string>?), bool? fieldsByKeys = default(bool?), string? expand = default(string?), List<string>? properties = default(List<string>?), bool? updateHistory = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get issue
        /// </summary>
        /// <remarks>
        /// Returns the details for an issue.  The issue is identified by its ID or key, however, if the identifier doesn&#39;t match an issue, a case-insensitive search and check for moved issues is performed. If a matching issue is found its details are returned, a 302 or other redirect is **not** returned. The issue key returned in the response is the key of the issue found.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="fields">A list of fields to return for the issue. This parameter accepts a comma-separated list. Use it to retrieve a subset of fields. Allowed values:   *  &#x60;*all&#x60; Returns all fields.  *  &#x60;*navigable&#x60; Returns navigable fields.  *  Any issue field, prefixed with a minus to exclude.  Examples:   *  &#x60;summary,comment&#x60; Returns only the summary and comments fields.  *  &#x60;-description&#x60; Returns all (default) fields except description.  *  &#x60;*navigable,-comment&#x60; Returns all navigable fields except comment.  This parameter may be specified multiple times. For example, &#x60;fields&#x3D;field1,field2&amp; fields&#x3D;field3&#x60;.  Note: All fields are returned by default. This differs from [Search for issues using JQL (GET)](#api-rest-api-2-search-get) and [Search for issues using JQL (POST)](#api-rest-api-2-search-post) where the default is all navigable fields. (optional)</param>
        /// <param name="fieldsByKeys">Whether fields in &#x60;fields&#x60; are referenced by keys rather than IDs. This parameter is useful where fields have been added by a connect app and a field&#39;s key may differ from its ID. (optional, default to false)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about the issues in the response. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;renderedFields&#x60; Returns field values rendered in HTML format.  *  &#x60;names&#x60; Returns the display name of each field.  *  &#x60;schema&#x60; Returns the schema describing a field type.  *  &#x60;transitions&#x60; Returns all possible transitions for the issue.  *  &#x60;editmeta&#x60; Returns information about how each field can be edited.  *  &#x60;changelog&#x60; Returns a list of recent updates to an issue, sorted by date, starting from the most recent.  *  &#x60;versionedRepresentations&#x60; Returns a JSON array for each version of a field&#39;s value, with the highest number representing the most recent version. Note: When included in the request, the &#x60;fields&#x60; parameter is ignored. (optional)</param>
        /// <param name="properties">A list of issue properties to return for the issue. This parameter accepts a comma-separated list. Allowed values:   *  &#x60;*all&#x60; Returns all issue properties.  *  Any issue property key, prefixed with a minus to exclude.  Examples:   *  &#x60;*all&#x60; Returns all properties.  *  &#x60;*all,-prop1&#x60; Returns all properties except &#x60;prop1&#x60;.  *  &#x60;prop1,prop2&#x60; Returns &#x60;prop1&#x60; and &#x60;prop2&#x60; properties.  This parameter may be specified multiple times. For example, &#x60;properties&#x3D;prop1,prop2&amp; properties&#x3D;prop3&#x60;. (optional)</param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. This also populates the [JQL issues search](#api-rest-api-2-search-get) &#x60;lastViewed&#x60; field. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueBean)</returns>
        System.Threading.Tasks.Task<ApiResponse<IssueBean>> GetIssueWithHttpInfoAsync(string issueIdOrKey, List<string>? fields = default(List<string>?), bool? fieldsByKeys = default(bool?), string? expand = default(string?), List<string>? properties = default(List<string>?), bool? updateHistory = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Get transitions
        /// </summary>
        /// <remarks>
        /// Returns either all transitions or a transition that can be performed by the user on an issue, based on the issue&#39;s status.  Note, if a request is made for a transition that does not exist or cannot be performed on the issue, given its status, the response will return any empty transitions list.  This operation can be accessed anonymously.  **[Permissions](#permissions) required: A list or transition is returned only when the user has:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  However, if the user does not have the *Transition issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) the response will not list any transitions.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about transitions in the response. This parameter accepts &#x60;transitions.fields&#x60;, which returns information about the fields in the transition screen for each transition. Fields hidden from the screen are not returned. Use this information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Transition issue](#api-rest-api-2-issue-issueIdOrKey-transitions-post). (optional)</param>
        /// <param name="transitionId">The ID of the transition. (optional)</param>
        /// <param name="skipRemoteOnlyCondition">Whether transitions with the condition *Hide From User Condition* are included in the response. (optional, default to false)</param>
        /// <param name="includeUnavailableTransitions">Whether details of transitions that fail a condition are included in the response (optional, default to false)</param>
        /// <param name="sortByOpsBarAndStatus">Whether the transitions are sorted by ops-bar sequence value first then category order (Todo, In Progress, Done) or only by ops-bar sequence value. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Transitions</returns>
        System.Threading.Tasks.Task<Transitions> GetTransitionsAsync(string issueIdOrKey, string? expand = default(string?), string? transitionId = default(string?), bool? skipRemoteOnlyCondition = default(bool?), bool? includeUnavailableTransitions = default(bool?), bool? sortByOpsBarAndStatus = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Get transitions
        /// </summary>
        /// <remarks>
        /// Returns either all transitions or a transition that can be performed by the user on an issue, based on the issue&#39;s status.  Note, if a request is made for a transition that does not exist or cannot be performed on the issue, given its status, the response will return any empty transitions list.  This operation can be accessed anonymously.  **[Permissions](#permissions) required: A list or transition is returned only when the user has:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  However, if the user does not have the *Transition issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) the response will not list any transitions.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about transitions in the response. This parameter accepts &#x60;transitions.fields&#x60;, which returns information about the fields in the transition screen for each transition. Fields hidden from the screen are not returned. Use this information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Transition issue](#api-rest-api-2-issue-issueIdOrKey-transitions-post). (optional)</param>
        /// <param name="transitionId">The ID of the transition. (optional)</param>
        /// <param name="skipRemoteOnlyCondition">Whether transitions with the condition *Hide From User Condition* are included in the response. (optional, default to false)</param>
        /// <param name="includeUnavailableTransitions">Whether details of transitions that fail a condition are included in the response (optional, default to false)</param>
        /// <param name="sortByOpsBarAndStatus">Whether the transitions are sorted by ops-bar sequence value first then category order (Todo, In Progress, Done) or only by ops-bar sequence value. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Transitions)</returns>
        System.Threading.Tasks.Task<ApiResponse<Transitions>> GetTransitionsWithHttpInfoAsync(string issueIdOrKey, string? expand = default(string?), string? transitionId = default(string?), bool? skipRemoteOnlyCondition = default(bool?), bool? includeUnavailableTransitions = default(bool?), bool? sortByOpsBarAndStatus = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Send notification for issue
        /// </summary>
        /// <remarks>
        /// Creates an email notification for an issue and adds it to the mail queue.  **[Permissions](#permissions) required:**   *  *Browse Projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">ID or key of the issue that the notification is sent for.</param>
        /// <param name="notification">The request object for the notification and recipients.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Object</returns>
        System.Threading.Tasks.Task<Object> NotifyAsync(string issueIdOrKey, Notification notification, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Send notification for issue
        /// </summary>
        /// <remarks>
        /// Creates an email notification for an issue and adds it to the mail queue.  **[Permissions](#permissions) required:**   *  *Browse Projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">ID or key of the issue that the notification is sent for.</param>
        /// <param name="notification">The request object for the notification and recipients.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        System.Threading.Tasks.Task<ApiResponse<Object>> NotifyWithHttpInfoAsync(string issueIdOrKey, Notification notification, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        /// <summary>
        /// Unarchive issue(s) by issue keys/ID
        /// </summary>
        /// <remarks>
        /// Enables admins to unarchive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) unarchived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t unarchive subtasks directly, only through their parent issues  *  you can only unarchive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be unarchived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueArchivalSyncResponse</returns>
        System.Threading.Tasks.Task<IssueArchivalSyncResponse> UnarchiveIssuesAsync(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));

        /// <summary>
        /// Unarchive issue(s) by issue keys/ID
        /// </summary>
        /// <remarks>
        /// Enables admins to unarchive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) unarchived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t unarchive subtasks directly, only through their parent issues  *  you can only unarchive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </remarks>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be unarchived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueArchivalSyncResponse)</returns>
        System.Threading.Tasks.Task<ApiResponse<IssueArchivalSyncResponse>> UnarchiveIssuesWithHttpInfoAsync(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        #endregion Asynchronous Operations
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public interface IIssuesApi : IIssuesApiSync, IIssuesApiAsync
    {

    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public partial class IssuesApi : IIssuesApi
    {
        private Projects.JiraPlatformApi.Client.ExceptionFactory _exceptionFactory = (name, response) => null;

        /// <summary>
        /// Initializes a new instance of the <see cref="IssuesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public IssuesApi() : this((string)null)
        {
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IssuesApi"/> class.
        /// </summary>
        /// <returns></returns>
        public IssuesApi(string basePath)
        {
            this.Configuration = Projects.JiraPlatformApi.Client.Configuration.MergeConfigurations(
                Projects.JiraPlatformApi.Client.GlobalConfiguration.Instance,
                new Projects.JiraPlatformApi.Client.Configuration { BasePath = basePath }
            );
            this.Client = new Projects.JiraPlatformApi.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Projects.JiraPlatformApi.Client.ApiClient(this.Configuration.BasePath);
            this.ExceptionFactory = Projects.JiraPlatformApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IssuesApi"/> class
        /// using Configuration object
        /// </summary>
        /// <param name="configuration">An instance of Configuration</param>
        /// <returns></returns>
        public IssuesApi(Projects.JiraPlatformApi.Client.Configuration configuration)
        {
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Configuration = Projects.JiraPlatformApi.Client.Configuration.MergeConfigurations(
                Projects.JiraPlatformApi.Client.GlobalConfiguration.Instance,
                configuration
            );
            this.Client = new Projects.JiraPlatformApi.Client.ApiClient(this.Configuration.BasePath);
            this.AsynchronousClient = new Projects.JiraPlatformApi.Client.ApiClient(this.Configuration.BasePath);
            ExceptionFactory = Projects.JiraPlatformApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// Initializes a new instance of the <see cref="IssuesApi"/> class
        /// using a Configuration object and client instance.
        /// </summary>
        /// <param name="client">The client interface for synchronous API access.</param>
        /// <param name="asyncClient">The client interface for asynchronous API access.</param>
        /// <param name="configuration">The configuration object.</param>
        public IssuesApi(Projects.JiraPlatformApi.Client.ISynchronousClient client, Projects.JiraPlatformApi.Client.IAsynchronousClient asyncClient, Projects.JiraPlatformApi.Client.IReadableConfiguration configuration)
        {
            if (client == null) throw new ArgumentNullException("client");
            if (asyncClient == null) throw new ArgumentNullException("asyncClient");
            if (configuration == null) throw new ArgumentNullException("configuration");

            this.Client = client;
            this.AsynchronousClient = asyncClient;
            this.Configuration = configuration;
            this.ExceptionFactory = Projects.JiraPlatformApi.Client.Configuration.DefaultExceptionFactory;
        }

        /// <summary>
        /// The client for accessing this underlying API asynchronously.
        /// </summary>
        public Projects.JiraPlatformApi.Client.IAsynchronousClient AsynchronousClient { get; set; }

        /// <summary>
        /// The client for accessing this underlying API synchronously.
        /// </summary>
        public Projects.JiraPlatformApi.Client.ISynchronousClient Client { get; set; }

        /// <summary>
        /// Gets the base path of the API client.
        /// </summary>
        /// <value>The base path</value>
        public string GetBasePath()
        {
            return this.Configuration.BasePath;
        }

        /// <summary>
        /// Gets or sets the configuration object
        /// </summary>
        /// <value>An instance of the Configuration</value>
        public Projects.JiraPlatformApi.Client.IReadableConfiguration Configuration { get; set; }

        /// <summary>
        /// Provides a factory method hook for the creation of exceptions.
        /// </summary>
        public Projects.JiraPlatformApi.Client.ExceptionFactory ExceptionFactory
        {
            get
            {
                if (_exceptionFactory != null && _exceptionFactory.GetInvocationList().Length > 1)
                {
                    throw new InvalidOperationException("Multicast delegate for ExceptionFactory is unsupported.");
                }
                return _exceptionFactory;
            }
            set { _exceptionFactory = value; }
        }

        /// <summary>
        /// Archive issue(s) by issue ID/key Enables admins to archive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) archived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be archived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueArchivalSyncResponse</returns>
        public IssueArchivalSyncResponse ArchiveIssues(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<IssueArchivalSyncResponse> localVarResponse = ArchiveIssuesWithHttpInfo(issueArchivalSyncRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Archive issue(s) by issue ID/key Enables admins to archive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) archived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be archived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueArchivalSyncResponse</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<IssueArchivalSyncResponse> ArchiveIssuesWithHttpInfo(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0)
        {
            // verify the required parameter 'issueArchivalSyncRequest' is set
            if (issueArchivalSyncRequest == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueArchivalSyncRequest' when calling IssuesApi->ArchiveIssues");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = issueArchivalSyncRequest;

            localVarRequestOptions.Operation = "IssuesApi.ArchiveIssues";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<IssueArchivalSyncResponse>("/rest/api/2/issue/archive", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ArchiveIssues", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Archive issue(s) by issue ID/key Enables admins to archive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) archived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be archived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueArchivalSyncResponse</returns>
        public async System.Threading.Tasks.Task<IssueArchivalSyncResponse> ArchiveIssuesAsync(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<IssueArchivalSyncResponse> localVarResponse = await ArchiveIssuesWithHttpInfoAsync(issueArchivalSyncRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Archive issue(s) by issue ID/key Enables admins to archive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) archived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be archived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueArchivalSyncResponse)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<IssueArchivalSyncResponse>> ArchiveIssuesWithHttpInfoAsync(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'issueArchivalSyncRequest' is set
            if (issueArchivalSyncRequest == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueArchivalSyncRequest' when calling IssuesApi->ArchiveIssues");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = issueArchivalSyncRequest;

            localVarRequestOptions.Operation = "IssuesApi.ArchiveIssues";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<IssueArchivalSyncResponse>("/rest/api/2/issue/archive", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ArchiveIssues", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Archive issue(s) by JQL Enables admins to archive up to 100,000 issues in a single request using JQL, returning the URL to check the status of the submitted request.  You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) and [cancel task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-cancel-post) APIs to manage the request.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request per jira instance can be active at any given time.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveIssueAsyncRequest">A JQL query specifying the issues to archive. Note that subtasks can only be archived through their parent issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>string</returns>
        public string ArchiveIssuesAsync(ArchiveIssueAsyncRequest archiveIssueAsyncRequest, int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<string> localVarResponse = ArchiveIssuesAsyncWithHttpInfo(archiveIssueAsyncRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Archive issue(s) by JQL Enables admins to archive up to 100,000 issues in a single request using JQL, returning the URL to check the status of the submitted request.  You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) and [cancel task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-cancel-post) APIs to manage the request.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request per jira instance can be active at any given time.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveIssueAsyncRequest">A JQL query specifying the issues to archive. Note that subtasks can only be archived through their parent issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of string</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<string> ArchiveIssuesAsyncWithHttpInfo(ArchiveIssueAsyncRequest archiveIssueAsyncRequest, int operationIndex = 0)
        {
            // verify the required parameter 'archiveIssueAsyncRequest' is set
            if (archiveIssueAsyncRequest == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'archiveIssueAsyncRequest' when calling IssuesApi->ArchiveIssuesAsync");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = archiveIssueAsyncRequest;

            localVarRequestOptions.Operation = "IssuesApi.ArchiveIssuesAsync";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<string>("/rest/api/2/issue/archive", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ArchiveIssuesAsync", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Archive issue(s) by JQL Enables admins to archive up to 100,000 issues in a single request using JQL, returning the URL to check the status of the submitted request.  You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) and [cancel task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-cancel-post) APIs to manage the request.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request per jira instance can be active at any given time.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveIssueAsyncRequest">A JQL query specifying the issues to archive. Note that subtasks can only be archived through their parent issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of string</returns>
        public async System.Threading.Tasks.Task<string> ArchiveIssuesAsyncAsync(ArchiveIssueAsyncRequest archiveIssueAsyncRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<string> localVarResponse = await ArchiveIssuesAsyncWithHttpInfoAsync(archiveIssueAsyncRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Archive issue(s) by JQL Enables admins to archive up to 100,000 issues in a single request using JQL, returning the URL to check the status of the submitted request.  You can use the [get task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-get) and [cancel task](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-tasks/#api-rest-api-3-task-taskid-cancel-post) APIs to manage the request.  **Note that:**   *  you can&#39;t archive subtasks directly, only through their parent issues  *  you can only archive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request per jira instance can be active at any given time.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archiveIssueAsyncRequest">A JQL query specifying the issues to archive. Note that subtasks can only be archived through their parent issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (string)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<string>> ArchiveIssuesAsyncWithHttpInfoAsync(ArchiveIssueAsyncRequest archiveIssueAsyncRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'archiveIssueAsyncRequest' is set
            if (archiveIssueAsyncRequest == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'archiveIssueAsyncRequest' when calling IssuesApi->ArchiveIssuesAsync");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = archiveIssueAsyncRequest;

            localVarRequestOptions.Operation = "IssuesApi.ArchiveIssuesAsync";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<string>("/rest/api/2/issue/archive", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ArchiveIssuesAsync", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Assign issue Assigns an issue to a user. Use this operation when the calling user does not have the *Edit Issues* permission but has the *Assign issue* permission for the project that the issue is in.  If &#x60;name&#x60; or &#x60;accountId&#x60; is set to:   *  &#x60;\&quot;-1\&quot;&#x60;, the issue is assigned to the default assignee for the project.  *  &#x60;null&#x60;, the issue is set to unassigned.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse Projects* and *Assign Issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue to be assigned.</param>
        /// <param name="user">The request object with the user that the issue is assigned to.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Object</returns>
        public Object AssignIssue(string issueIdOrKey, User user, int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<Object> localVarResponse = AssignIssueWithHttpInfo(issueIdOrKey, user);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Assign issue Assigns an issue to a user. Use this operation when the calling user does not have the *Edit Issues* permission but has the *Assign issue* permission for the project that the issue is in.  If &#x60;name&#x60; or &#x60;accountId&#x60; is set to:   *  &#x60;\&quot;-1\&quot;&#x60;, the issue is assigned to the default assignee for the project.  *  &#x60;null&#x60;, the issue is set to unassigned.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse Projects* and *Assign Issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue to be assigned.</param>
        /// <param name="user">The request object with the user that the issue is assigned to.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<Object> AssignIssueWithHttpInfo(string issueIdOrKey, User user, int operationIndex = 0)
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->AssignIssue");
            }

            // verify the required parameter 'user' is set
            if (user == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'user' when calling IssuesApi->AssignIssue");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            localVarRequestOptions.Data = user;

            localVarRequestOptions.Operation = "IssuesApi.AssignIssue";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/rest/api/2/issue/{issueIdOrKey}/assignee", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AssignIssue", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Assign issue Assigns an issue to a user. Use this operation when the calling user does not have the *Edit Issues* permission but has the *Assign issue* permission for the project that the issue is in.  If &#x60;name&#x60; or &#x60;accountId&#x60; is set to:   *  &#x60;\&quot;-1\&quot;&#x60;, the issue is assigned to the default assignee for the project.  *  &#x60;null&#x60;, the issue is set to unassigned.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse Projects* and *Assign Issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue to be assigned.</param>
        /// <param name="user">The request object with the user that the issue is assigned to.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Object</returns>
        public async System.Threading.Tasks.Task<Object> AssignIssueAsync(string issueIdOrKey, User user, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<Object> localVarResponse = await AssignIssueWithHttpInfoAsync(issueIdOrKey, user, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Assign issue Assigns an issue to a user. Use this operation when the calling user does not have the *Edit Issues* permission but has the *Assign issue* permission for the project that the issue is in.  If &#x60;name&#x60; or &#x60;accountId&#x60; is set to:   *  &#x60;\&quot;-1\&quot;&#x60;, the issue is assigned to the default assignee for the project.  *  &#x60;null&#x60;, the issue is set to unassigned.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse Projects* and *Assign Issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue to be assigned.</param>
        /// <param name="user">The request object with the user that the issue is assigned to.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<Object>> AssignIssueWithHttpInfoAsync(string issueIdOrKey, User user, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->AssignIssue");
            }

            // verify the required parameter 'user' is set
            if (user == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'user' when calling IssuesApi->AssignIssue");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            localVarRequestOptions.Data = user;

            localVarRequestOptions.Operation = "IssuesApi.AssignIssue";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/rest/api/2/issue/{issueIdOrKey}/assignee", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("AssignIssue", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create issue Creates an issue or, where the option to create subtasks is enabled in Jira, a subtask. A transition may be applied, to move the issue or subtask to a workflow step other than the default start step, and issue properties set.  The content of the issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issue&#39;s create screen.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which the issue or subtask is created.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. When provided, the issue type and request type are added to the user&#39;s history for a project. These values are then used to provide defaults on the issue create screen. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CreatedIssue</returns>
        public CreatedIssue CreateIssue(IssueUpdateDetails issueUpdateDetails, bool? updateHistory = default(bool?), int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<CreatedIssue> localVarResponse = CreateIssueWithHttpInfo(issueUpdateDetails, updateHistory);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create issue Creates an issue or, where the option to create subtasks is enabled in Jira, a subtask. A transition may be applied, to move the issue or subtask to a workflow step other than the default start step, and issue properties set.  The content of the issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issue&#39;s create screen.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which the issue or subtask is created.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. When provided, the issue type and request type are added to the user&#39;s history for a project. These values are then used to provide defaults on the issue create screen. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CreatedIssue</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<CreatedIssue> CreateIssueWithHttpInfo(IssueUpdateDetails issueUpdateDetails, bool? updateHistory = default(bool?), int operationIndex = 0)
        {
            // verify the required parameter 'issueUpdateDetails' is set
            if (issueUpdateDetails == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueUpdateDetails' when calling IssuesApi->CreateIssue");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (updateHistory != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "updateHistory", updateHistory));
            }
            localVarRequestOptions.Data = issueUpdateDetails;

            localVarRequestOptions.Operation = "IssuesApi.CreateIssue";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<CreatedIssue>("/rest/api/2/issue", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateIssue", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Create issue Creates an issue or, where the option to create subtasks is enabled in Jira, a subtask. A transition may be applied, to move the issue or subtask to a workflow step other than the default start step, and issue properties set.  The content of the issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issue&#39;s create screen.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which the issue or subtask is created.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. When provided, the issue type and request type are added to the user&#39;s history for a project. These values are then used to provide defaults on the issue create screen. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreatedIssue</returns>
        public async System.Threading.Tasks.Task<CreatedIssue> CreateIssueAsync(IssueUpdateDetails issueUpdateDetails, bool? updateHistory = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<CreatedIssue> localVarResponse = await CreateIssueWithHttpInfoAsync(issueUpdateDetails, updateHistory, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Create issue Creates an issue or, where the option to create subtasks is enabled in Jira, a subtask. A transition may be applied, to move the issue or subtask to a workflow step other than the default start step, and issue properties set.  The content of the issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issue&#39;s create screen.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which the issue or subtask is created.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. When provided, the issue type and request type are added to the user&#39;s history for a project. These values are then used to provide defaults on the issue create screen. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreatedIssue)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<CreatedIssue>> CreateIssueWithHttpInfoAsync(IssueUpdateDetails issueUpdateDetails, bool? updateHistory = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'issueUpdateDetails' is set
            if (issueUpdateDetails == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueUpdateDetails' when calling IssuesApi->CreateIssue");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (updateHistory != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "updateHistory", updateHistory));
            }
            localVarRequestOptions.Data = issueUpdateDetails;

            localVarRequestOptions.Operation = "IssuesApi.CreateIssue";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<CreatedIssue>("/rest/api/2/issue", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateIssue", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Bulk create issue Creates upto **50** issues and, where the option to create subtasks is enabled in Jira, subtasks. Transitions may be applied, to move the issues or subtasks to a workflow step other than the default start step, and issue properties set.  The content of each issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issues&#39; create screens.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; the must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which each issue or subtask is created.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuesUpdateBean"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>CreatedIssues</returns>
        public CreatedIssues CreateIssues(IssuesUpdateBean issuesUpdateBean, int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<CreatedIssues> localVarResponse = CreateIssuesWithHttpInfo(issuesUpdateBean);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Bulk create issue Creates upto **50** issues and, where the option to create subtasks is enabled in Jira, subtasks. Transitions may be applied, to move the issues or subtasks to a workflow step other than the default start step, and issue properties set.  The content of each issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issues&#39; create screens.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; the must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which each issue or subtask is created.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuesUpdateBean"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of CreatedIssues</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<CreatedIssues> CreateIssuesWithHttpInfo(IssuesUpdateBean issuesUpdateBean, int operationIndex = 0)
        {
            // verify the required parameter 'issuesUpdateBean' is set
            if (issuesUpdateBean == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issuesUpdateBean' when calling IssuesApi->CreateIssues");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = issuesUpdateBean;

            localVarRequestOptions.Operation = "IssuesApi.CreateIssues";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<CreatedIssues>("/rest/api/2/issue/bulk", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateIssues", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Bulk create issue Creates upto **50** issues and, where the option to create subtasks is enabled in Jira, subtasks. Transitions may be applied, to move the issues or subtasks to a workflow step other than the default start step, and issue properties set.  The content of each issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issues&#39; create screens.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; the must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which each issue or subtask is created.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuesUpdateBean"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of CreatedIssues</returns>
        public async System.Threading.Tasks.Task<CreatedIssues> CreateIssuesAsync(IssuesUpdateBean issuesUpdateBean, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<CreatedIssues> localVarResponse = await CreateIssuesWithHttpInfoAsync(issuesUpdateBean, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Bulk create issue Creates upto **50** issues and, where the option to create subtasks is enabled in Jira, subtasks. Transitions may be applied, to move the issues or subtasks to a workflow step other than the default start step, and issue properties set.  The content of each issue or subtask is defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be set in the issue or subtask are determined using the [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get). These are the same fields that appear on the issues&#39; create screens.  Creating a subtask differs from creating an issue as follows:   *  &#x60;issueType&#x60; must be set to a subtask issue type (use [ Get create issue metadata](#api-rest-api-2-issue-createmeta-get) to find subtask issue types).  *  &#x60;parent&#x60; the must contain the ID or key of the parent issue.  **[Permissions](#permissions) required:** *Browse projects* and *Create issues* [project permissions](https://confluence.atlassian.com/x/yodKLg) for the project in which each issue or subtask is created.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issuesUpdateBean"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (CreatedIssues)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<CreatedIssues>> CreateIssuesWithHttpInfoAsync(IssuesUpdateBean issuesUpdateBean, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'issuesUpdateBean' is set
            if (issuesUpdateBean == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issuesUpdateBean' when calling IssuesApi->CreateIssues");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = issuesUpdateBean;

            localVarRequestOptions.Operation = "IssuesApi.CreateIssues";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<CreatedIssues>("/rest/api/2/issue/bulk", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("CreateIssues", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete issue Deletes an issue.  An issue cannot be deleted if it has one or more subtasks. To delete an issue with subtasks, set &#x60;deleteSubtasks&#x60;. This causes the issue&#39;s subtasks to be deleted with the issue.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Delete issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="deleteSubtasks">Whether the issue&#39;s subtasks are deleted when the issue is deleted. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns></returns>
        public void DeleteIssue(string issueIdOrKey, string? deleteSubtasks = default(string?), int operationIndex = 0)
        {
            DeleteIssueWithHttpInfo(issueIdOrKey, deleteSubtasks);
        }

        /// <summary>
        /// Delete issue Deletes an issue.  An issue cannot be deleted if it has one or more subtasks. To delete an issue with subtasks, set &#x60;deleteSubtasks&#x60;. This causes the issue&#39;s subtasks to be deleted with the issue.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Delete issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="deleteSubtasks">Whether the issue&#39;s subtasks are deleted when the issue is deleted. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object(void)</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<Object> DeleteIssueWithHttpInfo(string issueIdOrKey, string? deleteSubtasks = default(string?), int operationIndex = 0)
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->DeleteIssue");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            if (deleteSubtasks != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "deleteSubtasks", deleteSubtasks));
            }

            localVarRequestOptions.Operation = "IssuesApi.DeleteIssue";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Delete<Object>("/rest/api/2/issue/{issueIdOrKey}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteIssue", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Delete issue Deletes an issue.  An issue cannot be deleted if it has one or more subtasks. To delete an issue with subtasks, set &#x60;deleteSubtasks&#x60;. This causes the issue&#39;s subtasks to be deleted with the issue.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Delete issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="deleteSubtasks">Whether the issue&#39;s subtasks are deleted when the issue is deleted. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of void</returns>
        public async System.Threading.Tasks.Task DeleteIssueAsync(string issueIdOrKey, string? deleteSubtasks = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            await DeleteIssueWithHttpInfoAsync(issueIdOrKey, deleteSubtasks, operationIndex, cancellationToken).ConfigureAwait(false);
        }

        /// <summary>
        /// Delete issue Deletes an issue.  An issue cannot be deleted if it has one or more subtasks. To delete an issue with subtasks, set &#x60;deleteSubtasks&#x60;. This causes the issue&#39;s subtasks to be deleted with the issue.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Delete issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project containing the issue.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="deleteSubtasks">Whether the issue&#39;s subtasks are deleted when the issue is deleted. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<Object>> DeleteIssueWithHttpInfoAsync(string issueIdOrKey, string? deleteSubtasks = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->DeleteIssue");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            if (deleteSubtasks != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "deleteSubtasks", deleteSubtasks));
            }

            localVarRequestOptions.Operation = "IssuesApi.DeleteIssue";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.DeleteAsync<Object>("/rest/api/2/issue/{issueIdOrKey}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DeleteIssue", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Transition issue Performs an issue transition and, if the transition has a screen, updates the fields from the transition screen.  sortByCategory To update the fields on the transition screen, specify the fields in the &#x60;fields&#x60; or &#x60;update&#x60; parameters in the request body. Get details about the fields using [ Get transitions](#api-rest-api-2-issue-issueIdOrKey-transitions-get) with the &#x60;transitions.fields&#x60; expand.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Transition issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Object</returns>
        public Object DoTransition(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<Object> localVarResponse = DoTransitionWithHttpInfo(issueIdOrKey, issueUpdateDetails);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Transition issue Performs an issue transition and, if the transition has a screen, updates the fields from the transition screen.  sortByCategory To update the fields on the transition screen, specify the fields in the &#x60;fields&#x60; or &#x60;update&#x60; parameters in the request body. Get details about the fields using [ Get transitions](#api-rest-api-2-issue-issueIdOrKey-transitions-get) with the &#x60;transitions.fields&#x60; expand.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Transition issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<Object> DoTransitionWithHttpInfo(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, int operationIndex = 0)
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->DoTransition");
            }

            // verify the required parameter 'issueUpdateDetails' is set
            if (issueUpdateDetails == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueUpdateDetails' when calling IssuesApi->DoTransition");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            localVarRequestOptions.Data = issueUpdateDetails;

            localVarRequestOptions.Operation = "IssuesApi.DoTransition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/rest/api/2/issue/{issueIdOrKey}/transitions", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DoTransition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Transition issue Performs an issue transition and, if the transition has a screen, updates the fields from the transition screen.  sortByCategory To update the fields on the transition screen, specify the fields in the &#x60;fields&#x60; or &#x60;update&#x60; parameters in the request body. Get details about the fields using [ Get transitions](#api-rest-api-2-issue-issueIdOrKey-transitions-get) with the &#x60;transitions.fields&#x60; expand.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Transition issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Object</returns>
        public async System.Threading.Tasks.Task<Object> DoTransitionAsync(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<Object> localVarResponse = await DoTransitionWithHttpInfoAsync(issueIdOrKey, issueUpdateDetails, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Transition issue Performs an issue transition and, if the transition has a screen, updates the fields from the transition screen.  sortByCategory To update the fields on the transition screen, specify the fields in the &#x60;fields&#x60; or &#x60;update&#x60; parameters in the request body. Get details about the fields using [ Get transitions](#api-rest-api-2-issue-issueIdOrKey-transitions-get) with the &#x60;transitions.fields&#x60; expand.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Transition issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<Object>> DoTransitionWithHttpInfoAsync(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->DoTransition");
            }

            // verify the required parameter 'issueUpdateDetails' is set
            if (issueUpdateDetails == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueUpdateDetails' when calling IssuesApi->DoTransition");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            localVarRequestOptions.Data = issueUpdateDetails;

            localVarRequestOptions.Operation = "IssuesApi.DoTransition";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/rest/api/2/issue/{issueIdOrKey}/transitions", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("DoTransition", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit issue Edits an issue. Issue properties may be updated as part of the edit. Please note that issue transition will be ignored as it is not supported yet.  The edits to the issue&#39;s fields are defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be edited are determined using [ Get edit issue metadata](#api-rest-api-2-issue-issueIdOrKey-editmeta-get).  The parent field may be set by key or ID. For standard issue types, the parent may be removed by setting &#x60;update.parent.set.none&#x60; to *true*.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can override the screen security configuration using &#x60;overrideScreenSecurity&#x60; and &#x60;overrideEditableFlag&#x60;.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="notifyUsers">Whether a notification email about the issue update is sent to all watchers. To disable the notification, administer Jira or administer project permissions are required. If the user doesn&#39;t have the necessary permission the request is ignored. (optional, default to true)</param>
        /// <param name="overrideScreenSecurity">Whether screen security is overridden to enable hidden fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="returnIssue">Whether the response should contain the issue with fields edited in this request. The returned issue will have the same format as in the [Get issue API](#api-rest-api-3-issue-issueidorkey-get). (optional, default to false)</param>
        /// <param name="expand">The Get issue API expand parameter to use in the response if the &#x60;returnIssue&#x60; parameter is &#x60;true&#x60;. (optional, default to &quot;&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Object</returns>
        public Object EditIssue(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, bool? notifyUsers = default(bool?), bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), bool? returnIssue = default(bool?), string? expand = default(string?), int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<Object> localVarResponse = EditIssueWithHttpInfo(issueIdOrKey, issueUpdateDetails, notifyUsers, overrideScreenSecurity, overrideEditableFlag, returnIssue, expand);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Edit issue Edits an issue. Issue properties may be updated as part of the edit. Please note that issue transition will be ignored as it is not supported yet.  The edits to the issue&#39;s fields are defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be edited are determined using [ Get edit issue metadata](#api-rest-api-2-issue-issueIdOrKey-editmeta-get).  The parent field may be set by key or ID. For standard issue types, the parent may be removed by setting &#x60;update.parent.set.none&#x60; to *true*.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can override the screen security configuration using &#x60;overrideScreenSecurity&#x60; and &#x60;overrideEditableFlag&#x60;.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="notifyUsers">Whether a notification email about the issue update is sent to all watchers. To disable the notification, administer Jira or administer project permissions are required. If the user doesn&#39;t have the necessary permission the request is ignored. (optional, default to true)</param>
        /// <param name="overrideScreenSecurity">Whether screen security is overridden to enable hidden fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="returnIssue">Whether the response should contain the issue with fields edited in this request. The returned issue will have the same format as in the [Get issue API](#api-rest-api-3-issue-issueidorkey-get). (optional, default to false)</param>
        /// <param name="expand">The Get issue API expand parameter to use in the response if the &#x60;returnIssue&#x60; parameter is &#x60;true&#x60;. (optional, default to &quot;&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<Object> EditIssueWithHttpInfo(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, bool? notifyUsers = default(bool?), bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), bool? returnIssue = default(bool?), string? expand = default(string?), int operationIndex = 0)
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->EditIssue");
            }

            // verify the required parameter 'issueUpdateDetails' is set
            if (issueUpdateDetails == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueUpdateDetails' when calling IssuesApi->EditIssue");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            if (notifyUsers != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "notifyUsers", notifyUsers));
            }
            if (overrideScreenSecurity != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "overrideScreenSecurity", overrideScreenSecurity));
            }
            if (overrideEditableFlag != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "overrideEditableFlag", overrideEditableFlag));
            }
            if (returnIssue != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "returnIssue", returnIssue));
            }
            if (expand != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "expand", expand));
            }
            localVarRequestOptions.Data = issueUpdateDetails;

            localVarRequestOptions.Operation = "IssuesApi.EditIssue";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<Object>("/rest/api/2/issue/{issueIdOrKey}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("EditIssue", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Edit issue Edits an issue. Issue properties may be updated as part of the edit. Please note that issue transition will be ignored as it is not supported yet.  The edits to the issue&#39;s fields are defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be edited are determined using [ Get edit issue metadata](#api-rest-api-2-issue-issueIdOrKey-editmeta-get).  The parent field may be set by key or ID. For standard issue types, the parent may be removed by setting &#x60;update.parent.set.none&#x60; to *true*.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can override the screen security configuration using &#x60;overrideScreenSecurity&#x60; and &#x60;overrideEditableFlag&#x60;.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="notifyUsers">Whether a notification email about the issue update is sent to all watchers. To disable the notification, administer Jira or administer project permissions are required. If the user doesn&#39;t have the necessary permission the request is ignored. (optional, default to true)</param>
        /// <param name="overrideScreenSecurity">Whether screen security is overridden to enable hidden fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="returnIssue">Whether the response should contain the issue with fields edited in this request. The returned issue will have the same format as in the [Get issue API](#api-rest-api-3-issue-issueidorkey-get). (optional, default to false)</param>
        /// <param name="expand">The Get issue API expand parameter to use in the response if the &#x60;returnIssue&#x60; parameter is &#x60;true&#x60;. (optional, default to &quot;&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Object</returns>
        public async System.Threading.Tasks.Task<Object> EditIssueAsync(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, bool? notifyUsers = default(bool?), bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), bool? returnIssue = default(bool?), string? expand = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<Object> localVarResponse = await EditIssueWithHttpInfoAsync(issueIdOrKey, issueUpdateDetails, notifyUsers, overrideScreenSecurity, overrideEditableFlag, returnIssue, expand, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Edit issue Edits an issue. Issue properties may be updated as part of the edit. Please note that issue transition will be ignored as it is not supported yet.  The edits to the issue&#39;s fields are defined using &#x60;update&#x60; and &#x60;fields&#x60;. The fields that can be edited are determined using [ Get edit issue metadata](#api-rest-api-2-issue-issueIdOrKey-editmeta-get).  The parent field may be set by key or ID. For standard issue types, the parent may be removed by setting &#x60;update.parent.set.none&#x60; to *true*.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can override the screen security configuration using &#x60;overrideScreenSecurity&#x60; and &#x60;overrideEditableFlag&#x60;.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* and *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueUpdateDetails"></param>
        /// <param name="notifyUsers">Whether a notification email about the issue update is sent to all watchers. To disable the notification, administer Jira or administer project permissions are required. If the user doesn&#39;t have the necessary permission the request is ignored. (optional, default to true)</param>
        /// <param name="overrideScreenSecurity">Whether screen security is overridden to enable hidden fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether screen security is overridden to enable uneditable fields to be edited. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="returnIssue">Whether the response should contain the issue with fields edited in this request. The returned issue will have the same format as in the [Get issue API](#api-rest-api-3-issue-issueidorkey-get). (optional, default to false)</param>
        /// <param name="expand">The Get issue API expand parameter to use in the response if the &#x60;returnIssue&#x60; parameter is &#x60;true&#x60;. (optional, default to &quot;&quot;)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<Object>> EditIssueWithHttpInfoAsync(string issueIdOrKey, IssueUpdateDetails issueUpdateDetails, bool? notifyUsers = default(bool?), bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), bool? returnIssue = default(bool?), string? expand = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->EditIssue");
            }

            // verify the required parameter 'issueUpdateDetails' is set
            if (issueUpdateDetails == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueUpdateDetails' when calling IssuesApi->EditIssue");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            if (notifyUsers != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "notifyUsers", notifyUsers));
            }
            if (overrideScreenSecurity != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "overrideScreenSecurity", overrideScreenSecurity));
            }
            if (overrideEditableFlag != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "overrideEditableFlag", overrideEditableFlag));
            }
            if (returnIssue != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "returnIssue", returnIssue));
            }
            if (expand != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "expand", expand));
            }
            localVarRequestOptions.Data = issueUpdateDetails;

            localVarRequestOptions.Operation = "IssuesApi.EditIssue";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<Object>("/rest/api/2/issue/{issueIdOrKey}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("EditIssue", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Export archived issue(s) Enables admins to retrieve details of all archived issues. Upon a successful request, the admin who submitted it will receive an email with a link to download a CSV file with the issue details.  Note that this API only exports the values of system fields and archival-specific fields (&#x60;ArchivedBy&#x60; and &#x60;ArchivedDate&#x60;). Custom fields aren&#39;t supported.  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request can be active at any given time.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archivedIssuesFilterRequest">You can filter the issues in your request by the &#x60;projects&#x60;, &#x60;archivedBy&#x60;, &#x60;archivedDate&#x60;, &#x60;issueTypes&#x60;, and &#x60;reporters&#x60; fields. All filters are optional. If you don&#39;t provide any filters, you&#39;ll get a list of up to one million archived issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ExportArchivedIssuesTaskProgressResponse</returns>
        public ExportArchivedIssuesTaskProgressResponse ExportArchivedIssues(ArchivedIssuesFilterRequest archivedIssuesFilterRequest, int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<ExportArchivedIssuesTaskProgressResponse> localVarResponse = ExportArchivedIssuesWithHttpInfo(archivedIssuesFilterRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Export archived issue(s) Enables admins to retrieve details of all archived issues. Upon a successful request, the admin who submitted it will receive an email with a link to download a CSV file with the issue details.  Note that this API only exports the values of system fields and archival-specific fields (&#x60;ArchivedBy&#x60; and &#x60;ArchivedDate&#x60;). Custom fields aren&#39;t supported.  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request can be active at any given time.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archivedIssuesFilterRequest">You can filter the issues in your request by the &#x60;projects&#x60;, &#x60;archivedBy&#x60;, &#x60;archivedDate&#x60;, &#x60;issueTypes&#x60;, and &#x60;reporters&#x60; fields. All filters are optional. If you don&#39;t provide any filters, you&#39;ll get a list of up to one million archived issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of ExportArchivedIssuesTaskProgressResponse</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<ExportArchivedIssuesTaskProgressResponse> ExportArchivedIssuesWithHttpInfo(ArchivedIssuesFilterRequest archivedIssuesFilterRequest, int operationIndex = 0)
        {
            // verify the required parameter 'archivedIssuesFilterRequest' is set
            if (archivedIssuesFilterRequest == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'archivedIssuesFilterRequest' when calling IssuesApi->ExportArchivedIssues");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = archivedIssuesFilterRequest;

            localVarRequestOptions.Operation = "IssuesApi.ExportArchivedIssues";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<ExportArchivedIssuesTaskProgressResponse>("/rest/api/2/issues/archive/export", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ExportArchivedIssues", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Export archived issue(s) Enables admins to retrieve details of all archived issues. Upon a successful request, the admin who submitted it will receive an email with a link to download a CSV file with the issue details.  Note that this API only exports the values of system fields and archival-specific fields (&#x60;ArchivedBy&#x60; and &#x60;ArchivedDate&#x60;). Custom fields aren&#39;t supported.  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request can be active at any given time.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archivedIssuesFilterRequest">You can filter the issues in your request by the &#x60;projects&#x60;, &#x60;archivedBy&#x60;, &#x60;archivedDate&#x60;, &#x60;issueTypes&#x60;, and &#x60;reporters&#x60; fields. All filters are optional. If you don&#39;t provide any filters, you&#39;ll get a list of up to one million archived issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ExportArchivedIssuesTaskProgressResponse</returns>
        public async System.Threading.Tasks.Task<ExportArchivedIssuesTaskProgressResponse> ExportArchivedIssuesAsync(ArchivedIssuesFilterRequest archivedIssuesFilterRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<ExportArchivedIssuesTaskProgressResponse> localVarResponse = await ExportArchivedIssuesWithHttpInfoAsync(archivedIssuesFilterRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Export archived issue(s) Enables admins to retrieve details of all archived issues. Upon a successful request, the admin who submitted it will receive an email with a link to download a CSV file with the issue details.  Note that this API only exports the values of system fields and archival-specific fields (&#x60;ArchivedBy&#x60; and &#x60;ArchivedDate&#x60;). Custom fields aren&#39;t supported.  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.  **Rate limiting:** Only a single request can be active at any given time.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="archivedIssuesFilterRequest">You can filter the issues in your request by the &#x60;projects&#x60;, &#x60;archivedBy&#x60;, &#x60;archivedDate&#x60;, &#x60;issueTypes&#x60;, and &#x60;reporters&#x60; fields. All filters are optional. If you don&#39;t provide any filters, you&#39;ll get a list of up to one million archived issues.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (ExportArchivedIssuesTaskProgressResponse)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<ExportArchivedIssuesTaskProgressResponse>> ExportArchivedIssuesWithHttpInfoAsync(ArchivedIssuesFilterRequest archivedIssuesFilterRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'archivedIssuesFilterRequest' is set
            if (archivedIssuesFilterRequest == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'archivedIssuesFilterRequest' when calling IssuesApi->ExportArchivedIssues");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = archivedIssuesFilterRequest;

            localVarRequestOptions.Operation = "IssuesApi.ExportArchivedIssues";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<ExportArchivedIssuesTaskProgressResponse>("/rest/api/2/issues/archive/export", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("ExportArchivedIssues", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get changelogs Returns a [paginated](#pagination) list of all changelogs for an issue sorted by date, starting from the oldest.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 100)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageBeanChangelog</returns>
        public PageBeanChangelog GetChangeLogs(string issueIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<PageBeanChangelog> localVarResponse = GetChangeLogsWithHttpInfo(issueIdOrKey, startAt, maxResults);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get changelogs Returns a [paginated](#pagination) list of all changelogs for an issue sorted by date, starting from the oldest.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 100)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageBeanChangelog</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<PageBeanChangelog> GetChangeLogsWithHttpInfo(string issueIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->GetChangeLogs");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            if (startAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "startAt", startAt));
            }
            if (maxResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "maxResults", maxResults));
            }

            localVarRequestOptions.Operation = "IssuesApi.GetChangeLogs";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageBeanChangelog>("/rest/api/2/issue/{issueIdOrKey}/changelog", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetChangeLogs", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get changelogs Returns a [paginated](#pagination) list of all changelogs for an issue sorted by date, starting from the oldest.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 100)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageBeanChangelog</returns>
        public async System.Threading.Tasks.Task<PageBeanChangelog> GetChangeLogsAsync(string issueIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<PageBeanChangelog> localVarResponse = await GetChangeLogsWithHttpInfoAsync(issueIdOrKey, startAt, maxResults, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get changelogs Returns a [paginated](#pagination) list of all changelogs for an issue sorted by date, starting from the oldest.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 100)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageBeanChangelog)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<PageBeanChangelog>> GetChangeLogsWithHttpInfoAsync(string issueIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->GetChangeLogs");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            if (startAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "startAt", startAt));
            }
            if (maxResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "maxResults", maxResults));
            }

            localVarRequestOptions.Operation = "IssuesApi.GetChangeLogs";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageBeanChangelog>("/rest/api/2/issue/{issueIdOrKey}/changelog", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetChangeLogs", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get changelogs by IDs Returns changelogs for an issue specified by a list of changelog IDs.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueChangelogIds"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageOfChangelogs</returns>
        public PageOfChangelogs GetChangeLogsByIds(string issueIdOrKey, IssueChangelogIds issueChangelogIds, int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<PageOfChangelogs> localVarResponse = GetChangeLogsByIdsWithHttpInfo(issueIdOrKey, issueChangelogIds);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get changelogs by IDs Returns changelogs for an issue specified by a list of changelog IDs.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueChangelogIds"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageOfChangelogs</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<PageOfChangelogs> GetChangeLogsByIdsWithHttpInfo(string issueIdOrKey, IssueChangelogIds issueChangelogIds, int operationIndex = 0)
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->GetChangeLogsByIds");
            }

            // verify the required parameter 'issueChangelogIds' is set
            if (issueChangelogIds == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueChangelogIds' when calling IssuesApi->GetChangeLogsByIds");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            localVarRequestOptions.Data = issueChangelogIds;

            localVarRequestOptions.Operation = "IssuesApi.GetChangeLogsByIds";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<PageOfChangelogs>("/rest/api/2/issue/{issueIdOrKey}/changelog/list", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetChangeLogsByIds", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get changelogs by IDs Returns changelogs for an issue specified by a list of changelog IDs.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueChangelogIds"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageOfChangelogs</returns>
        public async System.Threading.Tasks.Task<PageOfChangelogs> GetChangeLogsByIdsAsync(string issueIdOrKey, IssueChangelogIds issueChangelogIds, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<PageOfChangelogs> localVarResponse = await GetChangeLogsByIdsWithHttpInfoAsync(issueIdOrKey, issueChangelogIds, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get changelogs by IDs Returns changelogs for an issue specified by a list of changelog IDs.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="issueChangelogIds"></param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageOfChangelogs)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<PageOfChangelogs>> GetChangeLogsByIdsWithHttpInfoAsync(string issueIdOrKey, IssueChangelogIds issueChangelogIds, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->GetChangeLogsByIds");
            }

            // verify the required parameter 'issueChangelogIds' is set
            if (issueChangelogIds == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueChangelogIds' when calling IssuesApi->GetChangeLogsByIds");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            localVarRequestOptions.Data = issueChangelogIds;

            localVarRequestOptions.Operation = "IssuesApi.GetChangeLogsByIds";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<PageOfChangelogs>("/rest/api/2/issue/{issueIdOrKey}/changelog/list", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetChangeLogsByIds", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get create issue metadata Returns details of projects, issue types within projects, and, when requested, the create screen fields for each issue type for the user. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  Deprecated, see [Create Issue Meta Endpoint Deprecation Notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-1304).  The request can be restricted to specific projects or issue types using the query parameters. The response will contain information for the valid projects, issue types, or project and issue type combinations requested. Note that invalid project, issue type, or project and issue type combinations do not generate errors.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIds">List of project IDs. This parameter accepts a comma-separated list. Multiple project IDs can also be provided using an ampersand-separated list. For example, &#x60;projectIds&#x3D;10000,10001&amp;projectIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;projectKeys&#x60;. (optional)</param>
        /// <param name="projectKeys">List of project keys. This parameter accepts a comma-separated list. Multiple project keys can also be provided using an ampersand-separated list. For example, &#x60;projectKeys&#x3D;proj1,proj2&amp;projectKeys&#x3D;proj3&#x60;. This parameter may be provided with &#x60;projectIds&#x60;. (optional)</param>
        /// <param name="issuetypeIds">List of issue type IDs. This parameter accepts a comma-separated list. Multiple issue type IDs can also be provided using an ampersand-separated list. For example, &#x60;issuetypeIds&#x3D;10000,10001&amp;issuetypeIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;issuetypeNames&#x60;. (optional)</param>
        /// <param name="issuetypeNames">List of issue type names. This parameter accepts a comma-separated list. Multiple issue type names can also be provided using an ampersand-separated list. For example, &#x60;issuetypeNames&#x3D;name1,name2&amp;issuetypeNames&#x3D;name3&#x60;. This parameter may be provided with &#x60;issuetypeIds&#x60;. (optional)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about issue metadata in the response. This parameter accepts &#x60;projects.issuetypes.fields&#x60;, which returns information about the fields in the issue creation screen for each issue type. Fields hidden from the screen are not returned. Use the information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post). (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueCreateMetadata</returns>
        [Obsolete]
        public IssueCreateMetadata GetCreateIssueMeta(List<string>? projectIds = default(List<string>?), List<string>? projectKeys = default(List<string>?), List<string>? issuetypeIds = default(List<string>?), List<string>? issuetypeNames = default(List<string>?), string? expand = default(string?), int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<IssueCreateMetadata> localVarResponse = GetCreateIssueMetaWithHttpInfo(projectIds, projectKeys, issuetypeIds, issuetypeNames, expand);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get create issue metadata Returns details of projects, issue types within projects, and, when requested, the create screen fields for each issue type for the user. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  Deprecated, see [Create Issue Meta Endpoint Deprecation Notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-1304).  The request can be restricted to specific projects or issue types using the query parameters. The response will contain information for the valid projects, issue types, or project and issue type combinations requested. Note that invalid project, issue type, or project and issue type combinations do not generate errors.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIds">List of project IDs. This parameter accepts a comma-separated list. Multiple project IDs can also be provided using an ampersand-separated list. For example, &#x60;projectIds&#x3D;10000,10001&amp;projectIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;projectKeys&#x60;. (optional)</param>
        /// <param name="projectKeys">List of project keys. This parameter accepts a comma-separated list. Multiple project keys can also be provided using an ampersand-separated list. For example, &#x60;projectKeys&#x3D;proj1,proj2&amp;projectKeys&#x3D;proj3&#x60;. This parameter may be provided with &#x60;projectIds&#x60;. (optional)</param>
        /// <param name="issuetypeIds">List of issue type IDs. This parameter accepts a comma-separated list. Multiple issue type IDs can also be provided using an ampersand-separated list. For example, &#x60;issuetypeIds&#x3D;10000,10001&amp;issuetypeIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;issuetypeNames&#x60;. (optional)</param>
        /// <param name="issuetypeNames">List of issue type names. This parameter accepts a comma-separated list. Multiple issue type names can also be provided using an ampersand-separated list. For example, &#x60;issuetypeNames&#x3D;name1,name2&amp;issuetypeNames&#x3D;name3&#x60;. This parameter may be provided with &#x60;issuetypeIds&#x60;. (optional)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about issue metadata in the response. This parameter accepts &#x60;projects.issuetypes.fields&#x60;, which returns information about the fields in the issue creation screen for each issue type. Fields hidden from the screen are not returned. Use the information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post). (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueCreateMetadata</returns>
        [Obsolete]
        public Projects.JiraPlatformApi.Client.ApiResponse<IssueCreateMetadata> GetCreateIssueMetaWithHttpInfo(List<string>? projectIds = default(List<string>?), List<string>? projectKeys = default(List<string>?), List<string>? issuetypeIds = default(List<string>?), List<string>? issuetypeNames = default(List<string>?), string? expand = default(string?), int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (projectIds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("multi", "projectIds", projectIds));
            }
            if (projectKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("multi", "projectKeys", projectKeys));
            }
            if (issuetypeIds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("multi", "issuetypeIds", issuetypeIds));
            }
            if (issuetypeNames != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("multi", "issuetypeNames", issuetypeNames));
            }
            if (expand != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "expand", expand));
            }

            localVarRequestOptions.Operation = "IssuesApi.GetCreateIssueMeta";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<IssueCreateMetadata>("/rest/api/2/issue/createmeta", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCreateIssueMeta", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get create issue metadata Returns details of projects, issue types within projects, and, when requested, the create screen fields for each issue type for the user. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  Deprecated, see [Create Issue Meta Endpoint Deprecation Notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-1304).  The request can be restricted to specific projects or issue types using the query parameters. The response will contain information for the valid projects, issue types, or project and issue type combinations requested. Note that invalid project, issue type, or project and issue type combinations do not generate errors.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIds">List of project IDs. This parameter accepts a comma-separated list. Multiple project IDs can also be provided using an ampersand-separated list. For example, &#x60;projectIds&#x3D;10000,10001&amp;projectIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;projectKeys&#x60;. (optional)</param>
        /// <param name="projectKeys">List of project keys. This parameter accepts a comma-separated list. Multiple project keys can also be provided using an ampersand-separated list. For example, &#x60;projectKeys&#x3D;proj1,proj2&amp;projectKeys&#x3D;proj3&#x60;. This parameter may be provided with &#x60;projectIds&#x60;. (optional)</param>
        /// <param name="issuetypeIds">List of issue type IDs. This parameter accepts a comma-separated list. Multiple issue type IDs can also be provided using an ampersand-separated list. For example, &#x60;issuetypeIds&#x3D;10000,10001&amp;issuetypeIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;issuetypeNames&#x60;. (optional)</param>
        /// <param name="issuetypeNames">List of issue type names. This parameter accepts a comma-separated list. Multiple issue type names can also be provided using an ampersand-separated list. For example, &#x60;issuetypeNames&#x3D;name1,name2&amp;issuetypeNames&#x3D;name3&#x60;. This parameter may be provided with &#x60;issuetypeIds&#x60;. (optional)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about issue metadata in the response. This parameter accepts &#x60;projects.issuetypes.fields&#x60;, which returns information about the fields in the issue creation screen for each issue type. Fields hidden from the screen are not returned. Use the information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post). (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueCreateMetadata</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<IssueCreateMetadata> GetCreateIssueMetaAsync(List<string>? projectIds = default(List<string>?), List<string>? projectKeys = default(List<string>?), List<string>? issuetypeIds = default(List<string>?), List<string>? issuetypeNames = default(List<string>?), string? expand = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<IssueCreateMetadata> localVarResponse = await GetCreateIssueMetaWithHttpInfoAsync(projectIds, projectKeys, issuetypeIds, issuetypeNames, expand, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get create issue metadata Returns details of projects, issue types within projects, and, when requested, the create screen fields for each issue type for the user. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  Deprecated, see [Create Issue Meta Endpoint Deprecation Notice](https://developer.atlassian.com/cloud/jira/platform/changelog/#CHANGE-1304).  The request can be restricted to specific projects or issue types using the query parameters. The response will contain information for the valid projects, issue types, or project and issue type combinations requested. Note that invalid project, issue type, or project and issue type combinations do not generate errors.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIds">List of project IDs. This parameter accepts a comma-separated list. Multiple project IDs can also be provided using an ampersand-separated list. For example, &#x60;projectIds&#x3D;10000,10001&amp;projectIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;projectKeys&#x60;. (optional)</param>
        /// <param name="projectKeys">List of project keys. This parameter accepts a comma-separated list. Multiple project keys can also be provided using an ampersand-separated list. For example, &#x60;projectKeys&#x3D;proj1,proj2&amp;projectKeys&#x3D;proj3&#x60;. This parameter may be provided with &#x60;projectIds&#x60;. (optional)</param>
        /// <param name="issuetypeIds">List of issue type IDs. This parameter accepts a comma-separated list. Multiple issue type IDs can also be provided using an ampersand-separated list. For example, &#x60;issuetypeIds&#x3D;10000,10001&amp;issuetypeIds&#x3D;10020,10021&#x60;. This parameter may be provided with &#x60;issuetypeNames&#x60;. (optional)</param>
        /// <param name="issuetypeNames">List of issue type names. This parameter accepts a comma-separated list. Multiple issue type names can also be provided using an ampersand-separated list. For example, &#x60;issuetypeNames&#x3D;name1,name2&amp;issuetypeNames&#x3D;name3&#x60;. This parameter may be provided with &#x60;issuetypeIds&#x60;. (optional)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about issue metadata in the response. This parameter accepts &#x60;projects.issuetypes.fields&#x60;, which returns information about the fields in the issue creation screen for each issue type. Fields hidden from the screen are not returned. Use the information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post). (optional)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueCreateMetadata)</returns>
        [Obsolete]
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<IssueCreateMetadata>> GetCreateIssueMetaWithHttpInfoAsync(List<string>? projectIds = default(List<string>?), List<string>? projectKeys = default(List<string>?), List<string>? issuetypeIds = default(List<string>?), List<string>? issuetypeNames = default(List<string>?), string? expand = default(string?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            if (projectIds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("multi", "projectIds", projectIds));
            }
            if (projectKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("multi", "projectKeys", projectKeys));
            }
            if (issuetypeIds != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("multi", "issuetypeIds", issuetypeIds));
            }
            if (issuetypeNames != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("multi", "issuetypeNames", issuetypeNames));
            }
            if (expand != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "expand", expand));
            }

            localVarRequestOptions.Operation = "IssuesApi.GetCreateIssueMeta";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<IssueCreateMetadata>("/rest/api/2/issue/createmeta", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCreateIssueMeta", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get create field metadata for a project and issue type id Returns a page of field metadata for a specified project and issuetype id. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="issueTypeId">The issuetype ID.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageOfCreateMetaIssueTypeWithField</returns>
        public PageOfCreateMetaIssueTypeWithField GetCreateIssueMetaIssueTypeId(string projectIdOrKey, string issueTypeId, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<PageOfCreateMetaIssueTypeWithField> localVarResponse = GetCreateIssueMetaIssueTypeIdWithHttpInfo(projectIdOrKey, issueTypeId, startAt, maxResults);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get create field metadata for a project and issue type id Returns a page of field metadata for a specified project and issuetype id. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="issueTypeId">The issuetype ID.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageOfCreateMetaIssueTypeWithField</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<PageOfCreateMetaIssueTypeWithField> GetCreateIssueMetaIssueTypeIdWithHttpInfo(string projectIdOrKey, string issueTypeId, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'projectIdOrKey' is set
            if (projectIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'projectIdOrKey' when calling IssuesApi->GetCreateIssueMetaIssueTypeId");
            }

            // verify the required parameter 'issueTypeId' is set
            if (issueTypeId == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueTypeId' when calling IssuesApi->GetCreateIssueMetaIssueTypeId");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("projectIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(projectIdOrKey)); // path parameter
            localVarRequestOptions.PathParameters.Add("issueTypeId", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueTypeId)); // path parameter
            if (startAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "startAt", startAt));
            }
            if (maxResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "maxResults", maxResults));
            }

            localVarRequestOptions.Operation = "IssuesApi.GetCreateIssueMetaIssueTypeId";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageOfCreateMetaIssueTypeWithField>("/rest/api/2/issue/createmeta/{projectIdOrKey}/issuetypes/{issueTypeId}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCreateIssueMetaIssueTypeId", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get create field metadata for a project and issue type id Returns a page of field metadata for a specified project and issuetype id. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="issueTypeId">The issuetype ID.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageOfCreateMetaIssueTypeWithField</returns>
        public async System.Threading.Tasks.Task<PageOfCreateMetaIssueTypeWithField> GetCreateIssueMetaIssueTypeIdAsync(string projectIdOrKey, string issueTypeId, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<PageOfCreateMetaIssueTypeWithField> localVarResponse = await GetCreateIssueMetaIssueTypeIdWithHttpInfoAsync(projectIdOrKey, issueTypeId, startAt, maxResults, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get create field metadata for a project and issue type id Returns a page of field metadata for a specified project and issuetype id. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="issueTypeId">The issuetype ID.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageOfCreateMetaIssueTypeWithField)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<PageOfCreateMetaIssueTypeWithField>> GetCreateIssueMetaIssueTypeIdWithHttpInfoAsync(string projectIdOrKey, string issueTypeId, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'projectIdOrKey' is set
            if (projectIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'projectIdOrKey' when calling IssuesApi->GetCreateIssueMetaIssueTypeId");
            }

            // verify the required parameter 'issueTypeId' is set
            if (issueTypeId == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueTypeId' when calling IssuesApi->GetCreateIssueMetaIssueTypeId");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("projectIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(projectIdOrKey)); // path parameter
            localVarRequestOptions.PathParameters.Add("issueTypeId", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueTypeId)); // path parameter
            if (startAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "startAt", startAt));
            }
            if (maxResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "maxResults", maxResults));
            }

            localVarRequestOptions.Operation = "IssuesApi.GetCreateIssueMetaIssueTypeId";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageOfCreateMetaIssueTypeWithField>("/rest/api/2/issue/createmeta/{projectIdOrKey}/issuetypes/{issueTypeId}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCreateIssueMetaIssueTypeId", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get create metadata issue types for a project Returns a page of issue type metadata for a specified project. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>PageOfCreateMetaIssueTypes</returns>
        public PageOfCreateMetaIssueTypes GetCreateIssueMetaIssueTypes(string projectIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<PageOfCreateMetaIssueTypes> localVarResponse = GetCreateIssueMetaIssueTypesWithHttpInfo(projectIdOrKey, startAt, maxResults);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get create metadata issue types for a project Returns a page of issue type metadata for a specified project. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of PageOfCreateMetaIssueTypes</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<PageOfCreateMetaIssueTypes> GetCreateIssueMetaIssueTypesWithHttpInfo(string projectIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0)
        {
            // verify the required parameter 'projectIdOrKey' is set
            if (projectIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'projectIdOrKey' when calling IssuesApi->GetCreateIssueMetaIssueTypes");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("projectIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(projectIdOrKey)); // path parameter
            if (startAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "startAt", startAt));
            }
            if (maxResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "maxResults", maxResults));
            }

            localVarRequestOptions.Operation = "IssuesApi.GetCreateIssueMetaIssueTypes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<PageOfCreateMetaIssueTypes>("/rest/api/2/issue/createmeta/{projectIdOrKey}/issuetypes", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCreateIssueMetaIssueTypes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get create metadata issue types for a project Returns a page of issue type metadata for a specified project. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of PageOfCreateMetaIssueTypes</returns>
        public async System.Threading.Tasks.Task<PageOfCreateMetaIssueTypes> GetCreateIssueMetaIssueTypesAsync(string projectIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<PageOfCreateMetaIssueTypes> localVarResponse = await GetCreateIssueMetaIssueTypesWithHttpInfoAsync(projectIdOrKey, startAt, maxResults, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get create metadata issue types for a project Returns a page of issue type metadata for a specified project. Use the information to populate the requests in [ Create issue](#api-rest-api-2-issue-post) and [Create issues](#api-rest-api-2-issue-bulk-post).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:** *Create issues* [project permission](https://confluence.atlassian.com/x/yodKLg) in the requested projects.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="projectIdOrKey">The ID or key of the project.</param>
        /// <param name="startAt">The index of the first item to return in a page of results (page offset). (optional, default to 0)</param>
        /// <param name="maxResults">The maximum number of items to return per page. (optional, default to 50)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (PageOfCreateMetaIssueTypes)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<PageOfCreateMetaIssueTypes>> GetCreateIssueMetaIssueTypesWithHttpInfoAsync(string projectIdOrKey, int? startAt = default(int?), int? maxResults = default(int?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'projectIdOrKey' is set
            if (projectIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'projectIdOrKey' when calling IssuesApi->GetCreateIssueMetaIssueTypes");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("projectIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(projectIdOrKey)); // path parameter
            if (startAt != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "startAt", startAt));
            }
            if (maxResults != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "maxResults", maxResults));
            }

            localVarRequestOptions.Operation = "IssuesApi.GetCreateIssueMetaIssueTypes";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<PageOfCreateMetaIssueTypes>("/rest/api/2/issue/createmeta/{projectIdOrKey}/issuetypes", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetCreateIssueMetaIssueTypes", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get edit issue metadata Returns the edit screen fields for an issue that are visible to and editable by the user. Use the information to populate the requests in [Edit issue](#api-rest-api-2-issue-issueIdOrKey-put).  This endpoint will check for these conditions:  1.  Field is available on a field screen - through screen, screen scheme, issue type screen scheme, and issue type scheme configuration. &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 2.  Field is visible in the [field configuration](https://support.atlassian.com/jira-cloud-administration/docs/change-a-field-configuration/). &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 3.  Field is shown on the issue: each field has different conditions here. For example: Attachment field only shows if attachments are enabled. Assignee only shows if user has permissions to assign the issue. 4.  If a field is custom then it must have valid custom field context, applicable for its project and issue type. All system fields are assumed to have context in all projects and all issue types. 5.  Issue has a project, issue type, and status defined. 6.  Issue is assigned to a valid workflow, and the current status has assigned a workflow step. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 7.  The current workflow step is editable. This is true by default, but [can be disabled by setting](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) the &#x60;jira.issue.editable&#x60; property to &#x60;false&#x60;. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 8.  User has [Edit issues permission](https://support.atlassian.com/jira-cloud-administration/docs/permissions-for-company-managed-projects/). 9.  Workflow permissions allow editing a field. This is true by default but [can be modified](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) using &#x60;jira.permission.*&#x60; workflow properties.  Fields hidden using [Issue layout settings page](https://support.atlassian.com/jira-software-cloud/docs/configure-field-layout-in-the-issue-view/) remain editable.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can return additional details using:   *  &#x60;overrideScreenSecurity&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if fields are available through screens, and field configuration (conditions 1. and 2. from the list above).  *  &#x60;overrideEditableFlag&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if workflow is present and if the current step is editable (conditions 6. and 7. from the list above).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  Note: For any fields to be editable the user must have the *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="overrideScreenSecurity">Whether hidden fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether non-editable fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueUpdateMetadata</returns>
        public IssueUpdateMetadata GetEditIssueMeta(string issueIdOrKey, bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<IssueUpdateMetadata> localVarResponse = GetEditIssueMetaWithHttpInfo(issueIdOrKey, overrideScreenSecurity, overrideEditableFlag);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get edit issue metadata Returns the edit screen fields for an issue that are visible to and editable by the user. Use the information to populate the requests in [Edit issue](#api-rest-api-2-issue-issueIdOrKey-put).  This endpoint will check for these conditions:  1.  Field is available on a field screen - through screen, screen scheme, issue type screen scheme, and issue type scheme configuration. &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 2.  Field is visible in the [field configuration](https://support.atlassian.com/jira-cloud-administration/docs/change-a-field-configuration/). &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 3.  Field is shown on the issue: each field has different conditions here. For example: Attachment field only shows if attachments are enabled. Assignee only shows if user has permissions to assign the issue. 4.  If a field is custom then it must have valid custom field context, applicable for its project and issue type. All system fields are assumed to have context in all projects and all issue types. 5.  Issue has a project, issue type, and status defined. 6.  Issue is assigned to a valid workflow, and the current status has assigned a workflow step. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 7.  The current workflow step is editable. This is true by default, but [can be disabled by setting](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) the &#x60;jira.issue.editable&#x60; property to &#x60;false&#x60;. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 8.  User has [Edit issues permission](https://support.atlassian.com/jira-cloud-administration/docs/permissions-for-company-managed-projects/). 9.  Workflow permissions allow editing a field. This is true by default but [can be modified](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) using &#x60;jira.permission.*&#x60; workflow properties.  Fields hidden using [Issue layout settings page](https://support.atlassian.com/jira-software-cloud/docs/configure-field-layout-in-the-issue-view/) remain editable.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can return additional details using:   *  &#x60;overrideScreenSecurity&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if fields are available through screens, and field configuration (conditions 1. and 2. from the list above).  *  &#x60;overrideEditableFlag&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if workflow is present and if the current step is editable (conditions 6. and 7. from the list above).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  Note: For any fields to be editable the user must have the *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="overrideScreenSecurity">Whether hidden fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether non-editable fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueUpdateMetadata</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<IssueUpdateMetadata> GetEditIssueMetaWithHttpInfo(string issueIdOrKey, bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), int operationIndex = 0)
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->GetEditIssueMeta");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            if (overrideScreenSecurity != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "overrideScreenSecurity", overrideScreenSecurity));
            }
            if (overrideEditableFlag != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "overrideEditableFlag", overrideEditableFlag));
            }

            localVarRequestOptions.Operation = "IssuesApi.GetEditIssueMeta";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<IssueUpdateMetadata>("/rest/api/2/issue/{issueIdOrKey}/editmeta", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEditIssueMeta", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get edit issue metadata Returns the edit screen fields for an issue that are visible to and editable by the user. Use the information to populate the requests in [Edit issue](#api-rest-api-2-issue-issueIdOrKey-put).  This endpoint will check for these conditions:  1.  Field is available on a field screen - through screen, screen scheme, issue type screen scheme, and issue type scheme configuration. &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 2.  Field is visible in the [field configuration](https://support.atlassian.com/jira-cloud-administration/docs/change-a-field-configuration/). &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 3.  Field is shown on the issue: each field has different conditions here. For example: Attachment field only shows if attachments are enabled. Assignee only shows if user has permissions to assign the issue. 4.  If a field is custom then it must have valid custom field context, applicable for its project and issue type. All system fields are assumed to have context in all projects and all issue types. 5.  Issue has a project, issue type, and status defined. 6.  Issue is assigned to a valid workflow, and the current status has assigned a workflow step. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 7.  The current workflow step is editable. This is true by default, but [can be disabled by setting](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) the &#x60;jira.issue.editable&#x60; property to &#x60;false&#x60;. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 8.  User has [Edit issues permission](https://support.atlassian.com/jira-cloud-administration/docs/permissions-for-company-managed-projects/). 9.  Workflow permissions allow editing a field. This is true by default but [can be modified](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) using &#x60;jira.permission.*&#x60; workflow properties.  Fields hidden using [Issue layout settings page](https://support.atlassian.com/jira-software-cloud/docs/configure-field-layout-in-the-issue-view/) remain editable.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can return additional details using:   *  &#x60;overrideScreenSecurity&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if fields are available through screens, and field configuration (conditions 1. and 2. from the list above).  *  &#x60;overrideEditableFlag&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if workflow is present and if the current step is editable (conditions 6. and 7. from the list above).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  Note: For any fields to be editable the user must have the *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="overrideScreenSecurity">Whether hidden fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether non-editable fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueUpdateMetadata</returns>
        public async System.Threading.Tasks.Task<IssueUpdateMetadata> GetEditIssueMetaAsync(string issueIdOrKey, bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<IssueUpdateMetadata> localVarResponse = await GetEditIssueMetaWithHttpInfoAsync(issueIdOrKey, overrideScreenSecurity, overrideEditableFlag, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get edit issue metadata Returns the edit screen fields for an issue that are visible to and editable by the user. Use the information to populate the requests in [Edit issue](#api-rest-api-2-issue-issueIdOrKey-put).  This endpoint will check for these conditions:  1.  Field is available on a field screen - through screen, screen scheme, issue type screen scheme, and issue type scheme configuration. &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 2.  Field is visible in the [field configuration](https://support.atlassian.com/jira-cloud-administration/docs/change-a-field-configuration/). &#x60;overrideScreenSecurity&#x3D;true&#x60; skips this condition. 3.  Field is shown on the issue: each field has different conditions here. For example: Attachment field only shows if attachments are enabled. Assignee only shows if user has permissions to assign the issue. 4.  If a field is custom then it must have valid custom field context, applicable for its project and issue type. All system fields are assumed to have context in all projects and all issue types. 5.  Issue has a project, issue type, and status defined. 6.  Issue is assigned to a valid workflow, and the current status has assigned a workflow step. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 7.  The current workflow step is editable. This is true by default, but [can be disabled by setting](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) the &#x60;jira.issue.editable&#x60; property to &#x60;false&#x60;. &#x60;overrideEditableFlag&#x3D;true&#x60; skips this condition. 8.  User has [Edit issues permission](https://support.atlassian.com/jira-cloud-administration/docs/permissions-for-company-managed-projects/). 9.  Workflow permissions allow editing a field. This is true by default but [can be modified](https://support.atlassian.com/jira-cloud-administration/docs/use-workflow-properties/) using &#x60;jira.permission.*&#x60; workflow properties.  Fields hidden using [Issue layout settings page](https://support.atlassian.com/jira-software-cloud/docs/configure-field-layout-in-the-issue-view/) remain editable.  Connect apps having an app user with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg), can return additional details using:   *  &#x60;overrideScreenSecurity&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if fields are available through screens, and field configuration (conditions 1. and 2. from the list above).  *  &#x60;overrideEditableFlag&#x60; When this flag is &#x60;true&#x60;, then this endpoint skips checking if workflow is present and if the current step is editable (conditions 6. and 7. from the list above).  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  Note: For any fields to be editable the user must have the *Edit issues* [project permission](https://confluence.atlassian.com/x/yodKLg) for the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="overrideScreenSecurity">Whether hidden fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="overrideEditableFlag">Whether non-editable fields are returned. Available to Connect app users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg) and Forge apps acting on behalf of users with *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg). (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueUpdateMetadata)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<IssueUpdateMetadata>> GetEditIssueMetaWithHttpInfoAsync(string issueIdOrKey, bool? overrideScreenSecurity = default(bool?), bool? overrideEditableFlag = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->GetEditIssueMeta");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            if (overrideScreenSecurity != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "overrideScreenSecurity", overrideScreenSecurity));
            }
            if (overrideEditableFlag != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "overrideEditableFlag", overrideEditableFlag));
            }

            localVarRequestOptions.Operation = "IssuesApi.GetEditIssueMeta";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<IssueUpdateMetadata>("/rest/api/2/issue/{issueIdOrKey}/editmeta", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEditIssueMeta", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get events Returns all issue events.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>List&lt;IssueEvent&gt;</returns>
        public List<IssueEvent> GetEvents(int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<List<IssueEvent>> localVarResponse = GetEventsWithHttpInfo();
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get events Returns all issue events.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of List&lt;IssueEvent&gt;</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<List<IssueEvent>> GetEventsWithHttpInfo(int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }


            localVarRequestOptions.Operation = "IssuesApi.GetEvents";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<List<IssueEvent>>("/rest/api/2/events", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEvents", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get events Returns all issue events.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of List&lt;IssueEvent&gt;</returns>
        public async System.Threading.Tasks.Task<List<IssueEvent>> GetEventsAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<List<IssueEvent>> localVarResponse = await GetEventsWithHttpInfoAsync(operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get events Returns all issue events.  **[Permissions](#permissions) required:** *Administer Jira* [global permission](https://confluence.atlassian.com/x/x4dKLg).
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (List&lt;IssueEvent&gt;)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<List<IssueEvent>>> GetEventsWithHttpInfoAsync(int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }


            localVarRequestOptions.Operation = "IssuesApi.GetEvents";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<List<IssueEvent>>("/rest/api/2/events", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetEvents", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get issue Returns the details for an issue.  The issue is identified by its ID or key, however, if the identifier doesn&#39;t match an issue, a case-insensitive search and check for moved issues is performed. If a matching issue is found its details are returned, a 302 or other redirect is **not** returned. The issue key returned in the response is the key of the issue found.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="fields">A list of fields to return for the issue. This parameter accepts a comma-separated list. Use it to retrieve a subset of fields. Allowed values:   *  &#x60;*all&#x60; Returns all fields.  *  &#x60;*navigable&#x60; Returns navigable fields.  *  Any issue field, prefixed with a minus to exclude.  Examples:   *  &#x60;summary,comment&#x60; Returns only the summary and comments fields.  *  &#x60;-description&#x60; Returns all (default) fields except description.  *  &#x60;*navigable,-comment&#x60; Returns all navigable fields except comment.  This parameter may be specified multiple times. For example, &#x60;fields&#x3D;field1,field2&amp; fields&#x3D;field3&#x60;.  Note: All fields are returned by default. This differs from [Search for issues using JQL (GET)](#api-rest-api-2-search-get) and [Search for issues using JQL (POST)](#api-rest-api-2-search-post) where the default is all navigable fields. (optional)</param>
        /// <param name="fieldsByKeys">Whether fields in &#x60;fields&#x60; are referenced by keys rather than IDs. This parameter is useful where fields have been added by a connect app and a field&#39;s key may differ from its ID. (optional, default to false)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about the issues in the response. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;renderedFields&#x60; Returns field values rendered in HTML format.  *  &#x60;names&#x60; Returns the display name of each field.  *  &#x60;schema&#x60; Returns the schema describing a field type.  *  &#x60;transitions&#x60; Returns all possible transitions for the issue.  *  &#x60;editmeta&#x60; Returns information about how each field can be edited.  *  &#x60;changelog&#x60; Returns a list of recent updates to an issue, sorted by date, starting from the most recent.  *  &#x60;versionedRepresentations&#x60; Returns a JSON array for each version of a field&#39;s value, with the highest number representing the most recent version. Note: When included in the request, the &#x60;fields&#x60; parameter is ignored. (optional)</param>
        /// <param name="properties">A list of issue properties to return for the issue. This parameter accepts a comma-separated list. Allowed values:   *  &#x60;*all&#x60; Returns all issue properties.  *  Any issue property key, prefixed with a minus to exclude.  Examples:   *  &#x60;*all&#x60; Returns all properties.  *  &#x60;*all,-prop1&#x60; Returns all properties except &#x60;prop1&#x60;.  *  &#x60;prop1,prop2&#x60; Returns &#x60;prop1&#x60; and &#x60;prop2&#x60; properties.  This parameter may be specified multiple times. For example, &#x60;properties&#x3D;prop1,prop2&amp; properties&#x3D;prop3&#x60;. (optional)</param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. This also populates the [JQL issues search](#api-rest-api-2-search-get) &#x60;lastViewed&#x60; field. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueBean</returns>
        public IssueBean GetIssue(string issueIdOrKey, List<string>? fields = default(List<string>?), bool? fieldsByKeys = default(bool?), string? expand = default(string?), List<string>? properties = default(List<string>?), bool? updateHistory = default(bool?), int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<IssueBean> localVarResponse = GetIssueWithHttpInfo(issueIdOrKey, fields, fieldsByKeys, expand, properties, updateHistory);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get issue Returns the details for an issue.  The issue is identified by its ID or key, however, if the identifier doesn&#39;t match an issue, a case-insensitive search and check for moved issues is performed. If a matching issue is found its details are returned, a 302 or other redirect is **not** returned. The issue key returned in the response is the key of the issue found.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="fields">A list of fields to return for the issue. This parameter accepts a comma-separated list. Use it to retrieve a subset of fields. Allowed values:   *  &#x60;*all&#x60; Returns all fields.  *  &#x60;*navigable&#x60; Returns navigable fields.  *  Any issue field, prefixed with a minus to exclude.  Examples:   *  &#x60;summary,comment&#x60; Returns only the summary and comments fields.  *  &#x60;-description&#x60; Returns all (default) fields except description.  *  &#x60;*navigable,-comment&#x60; Returns all navigable fields except comment.  This parameter may be specified multiple times. For example, &#x60;fields&#x3D;field1,field2&amp; fields&#x3D;field3&#x60;.  Note: All fields are returned by default. This differs from [Search for issues using JQL (GET)](#api-rest-api-2-search-get) and [Search for issues using JQL (POST)](#api-rest-api-2-search-post) where the default is all navigable fields. (optional)</param>
        /// <param name="fieldsByKeys">Whether fields in &#x60;fields&#x60; are referenced by keys rather than IDs. This parameter is useful where fields have been added by a connect app and a field&#39;s key may differ from its ID. (optional, default to false)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about the issues in the response. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;renderedFields&#x60; Returns field values rendered in HTML format.  *  &#x60;names&#x60; Returns the display name of each field.  *  &#x60;schema&#x60; Returns the schema describing a field type.  *  &#x60;transitions&#x60; Returns all possible transitions for the issue.  *  &#x60;editmeta&#x60; Returns information about how each field can be edited.  *  &#x60;changelog&#x60; Returns a list of recent updates to an issue, sorted by date, starting from the most recent.  *  &#x60;versionedRepresentations&#x60; Returns a JSON array for each version of a field&#39;s value, with the highest number representing the most recent version. Note: When included in the request, the &#x60;fields&#x60; parameter is ignored. (optional)</param>
        /// <param name="properties">A list of issue properties to return for the issue. This parameter accepts a comma-separated list. Allowed values:   *  &#x60;*all&#x60; Returns all issue properties.  *  Any issue property key, prefixed with a minus to exclude.  Examples:   *  &#x60;*all&#x60; Returns all properties.  *  &#x60;*all,-prop1&#x60; Returns all properties except &#x60;prop1&#x60;.  *  &#x60;prop1,prop2&#x60; Returns &#x60;prop1&#x60; and &#x60;prop2&#x60; properties.  This parameter may be specified multiple times. For example, &#x60;properties&#x3D;prop1,prop2&amp; properties&#x3D;prop3&#x60;. (optional)</param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. This also populates the [JQL issues search](#api-rest-api-2-search-get) &#x60;lastViewed&#x60; field. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueBean</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<IssueBean> GetIssueWithHttpInfo(string issueIdOrKey, List<string>? fields = default(List<string>?), bool? fieldsByKeys = default(bool?), string? expand = default(string?), List<string>? properties = default(List<string>?), bool? updateHistory = default(bool?), int operationIndex = 0)
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->GetIssue");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            if (fields != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("multi", "fields", fields));
            }
            if (fieldsByKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "fieldsByKeys", fieldsByKeys));
            }
            if (expand != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "expand", expand));
            }
            if (properties != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("multi", "properties", properties));
            }
            if (updateHistory != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "updateHistory", updateHistory));
            }

            localVarRequestOptions.Operation = "IssuesApi.GetIssue";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<IssueBean>("/rest/api/2/issue/{issueIdOrKey}", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetIssue", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get issue Returns the details for an issue.  The issue is identified by its ID or key, however, if the identifier doesn&#39;t match an issue, a case-insensitive search and check for moved issues is performed. If a matching issue is found its details are returned, a 302 or other redirect is **not** returned. The issue key returned in the response is the key of the issue found.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="fields">A list of fields to return for the issue. This parameter accepts a comma-separated list. Use it to retrieve a subset of fields. Allowed values:   *  &#x60;*all&#x60; Returns all fields.  *  &#x60;*navigable&#x60; Returns navigable fields.  *  Any issue field, prefixed with a minus to exclude.  Examples:   *  &#x60;summary,comment&#x60; Returns only the summary and comments fields.  *  &#x60;-description&#x60; Returns all (default) fields except description.  *  &#x60;*navigable,-comment&#x60; Returns all navigable fields except comment.  This parameter may be specified multiple times. For example, &#x60;fields&#x3D;field1,field2&amp; fields&#x3D;field3&#x60;.  Note: All fields are returned by default. This differs from [Search for issues using JQL (GET)](#api-rest-api-2-search-get) and [Search for issues using JQL (POST)](#api-rest-api-2-search-post) where the default is all navigable fields. (optional)</param>
        /// <param name="fieldsByKeys">Whether fields in &#x60;fields&#x60; are referenced by keys rather than IDs. This parameter is useful where fields have been added by a connect app and a field&#39;s key may differ from its ID. (optional, default to false)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about the issues in the response. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;renderedFields&#x60; Returns field values rendered in HTML format.  *  &#x60;names&#x60; Returns the display name of each field.  *  &#x60;schema&#x60; Returns the schema describing a field type.  *  &#x60;transitions&#x60; Returns all possible transitions for the issue.  *  &#x60;editmeta&#x60; Returns information about how each field can be edited.  *  &#x60;changelog&#x60; Returns a list of recent updates to an issue, sorted by date, starting from the most recent.  *  &#x60;versionedRepresentations&#x60; Returns a JSON array for each version of a field&#39;s value, with the highest number representing the most recent version. Note: When included in the request, the &#x60;fields&#x60; parameter is ignored. (optional)</param>
        /// <param name="properties">A list of issue properties to return for the issue. This parameter accepts a comma-separated list. Allowed values:   *  &#x60;*all&#x60; Returns all issue properties.  *  Any issue property key, prefixed with a minus to exclude.  Examples:   *  &#x60;*all&#x60; Returns all properties.  *  &#x60;*all,-prop1&#x60; Returns all properties except &#x60;prop1&#x60;.  *  &#x60;prop1,prop2&#x60; Returns &#x60;prop1&#x60; and &#x60;prop2&#x60; properties.  This parameter may be specified multiple times. For example, &#x60;properties&#x3D;prop1,prop2&amp; properties&#x3D;prop3&#x60;. (optional)</param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. This also populates the [JQL issues search](#api-rest-api-2-search-get) &#x60;lastViewed&#x60; field. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueBean</returns>
        public async System.Threading.Tasks.Task<IssueBean> GetIssueAsync(string issueIdOrKey, List<string>? fields = default(List<string>?), bool? fieldsByKeys = default(bool?), string? expand = default(string?), List<string>? properties = default(List<string>?), bool? updateHistory = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<IssueBean> localVarResponse = await GetIssueWithHttpInfoAsync(issueIdOrKey, fields, fieldsByKeys, expand, properties, updateHistory, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get issue Returns the details for an issue.  The issue is identified by its ID or key, however, if the identifier doesn&#39;t match an issue, a case-insensitive search and check for moved issues is performed. If a matching issue is found its details are returned, a 302 or other redirect is **not** returned. The issue key returned in the response is the key of the issue found.  This operation can be accessed anonymously.  **[Permissions](#permissions) required:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="fields">A list of fields to return for the issue. This parameter accepts a comma-separated list. Use it to retrieve a subset of fields. Allowed values:   *  &#x60;*all&#x60; Returns all fields.  *  &#x60;*navigable&#x60; Returns navigable fields.  *  Any issue field, prefixed with a minus to exclude.  Examples:   *  &#x60;summary,comment&#x60; Returns only the summary and comments fields.  *  &#x60;-description&#x60; Returns all (default) fields except description.  *  &#x60;*navigable,-comment&#x60; Returns all navigable fields except comment.  This parameter may be specified multiple times. For example, &#x60;fields&#x3D;field1,field2&amp; fields&#x3D;field3&#x60;.  Note: All fields are returned by default. This differs from [Search for issues using JQL (GET)](#api-rest-api-2-search-get) and [Search for issues using JQL (POST)](#api-rest-api-2-search-post) where the default is all navigable fields. (optional)</param>
        /// <param name="fieldsByKeys">Whether fields in &#x60;fields&#x60; are referenced by keys rather than IDs. This parameter is useful where fields have been added by a connect app and a field&#39;s key may differ from its ID. (optional, default to false)</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about the issues in the response. This parameter accepts a comma-separated list. Expand options include:   *  &#x60;renderedFields&#x60; Returns field values rendered in HTML format.  *  &#x60;names&#x60; Returns the display name of each field.  *  &#x60;schema&#x60; Returns the schema describing a field type.  *  &#x60;transitions&#x60; Returns all possible transitions for the issue.  *  &#x60;editmeta&#x60; Returns information about how each field can be edited.  *  &#x60;changelog&#x60; Returns a list of recent updates to an issue, sorted by date, starting from the most recent.  *  &#x60;versionedRepresentations&#x60; Returns a JSON array for each version of a field&#39;s value, with the highest number representing the most recent version. Note: When included in the request, the &#x60;fields&#x60; parameter is ignored. (optional)</param>
        /// <param name="properties">A list of issue properties to return for the issue. This parameter accepts a comma-separated list. Allowed values:   *  &#x60;*all&#x60; Returns all issue properties.  *  Any issue property key, prefixed with a minus to exclude.  Examples:   *  &#x60;*all&#x60; Returns all properties.  *  &#x60;*all,-prop1&#x60; Returns all properties except &#x60;prop1&#x60;.  *  &#x60;prop1,prop2&#x60; Returns &#x60;prop1&#x60; and &#x60;prop2&#x60; properties.  This parameter may be specified multiple times. For example, &#x60;properties&#x3D;prop1,prop2&amp; properties&#x3D;prop3&#x60;. (optional)</param>
        /// <param name="updateHistory">Whether the project in which the issue is created is added to the user&#39;s **Recently viewed** project list, as shown under **Projects** in Jira. This also populates the [JQL issues search](#api-rest-api-2-search-get) &#x60;lastViewed&#x60; field. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueBean)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<IssueBean>> GetIssueWithHttpInfoAsync(string issueIdOrKey, List<string>? fields = default(List<string>?), bool? fieldsByKeys = default(bool?), string? expand = default(string?), List<string>? properties = default(List<string>?), bool? updateHistory = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->GetIssue");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            if (fields != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("multi", "fields", fields));
            }
            if (fieldsByKeys != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "fieldsByKeys", fieldsByKeys));
            }
            if (expand != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "expand", expand));
            }
            if (properties != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("multi", "properties", properties));
            }
            if (updateHistory != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "updateHistory", updateHistory));
            }

            localVarRequestOptions.Operation = "IssuesApi.GetIssue";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<IssueBean>("/rest/api/2/issue/{issueIdOrKey}", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetIssue", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get transitions Returns either all transitions or a transition that can be performed by the user on an issue, based on the issue&#39;s status.  Note, if a request is made for a transition that does not exist or cannot be performed on the issue, given its status, the response will return any empty transitions list.  This operation can be accessed anonymously.  **[Permissions](#permissions) required: A list or transition is returned only when the user has:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  However, if the user does not have the *Transition issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) the response will not list any transitions.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about transitions in the response. This parameter accepts &#x60;transitions.fields&#x60;, which returns information about the fields in the transition screen for each transition. Fields hidden from the screen are not returned. Use this information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Transition issue](#api-rest-api-2-issue-issueIdOrKey-transitions-post). (optional)</param>
        /// <param name="transitionId">The ID of the transition. (optional)</param>
        /// <param name="skipRemoteOnlyCondition">Whether transitions with the condition *Hide From User Condition* are included in the response. (optional, default to false)</param>
        /// <param name="includeUnavailableTransitions">Whether details of transitions that fail a condition are included in the response (optional, default to false)</param>
        /// <param name="sortByOpsBarAndStatus">Whether the transitions are sorted by ops-bar sequence value first then category order (Todo, In Progress, Done) or only by ops-bar sequence value. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Transitions</returns>
        public Transitions GetTransitions(string issueIdOrKey, string? expand = default(string?), string? transitionId = default(string?), bool? skipRemoteOnlyCondition = default(bool?), bool? includeUnavailableTransitions = default(bool?), bool? sortByOpsBarAndStatus = default(bool?), int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<Transitions> localVarResponse = GetTransitionsWithHttpInfo(issueIdOrKey, expand, transitionId, skipRemoteOnlyCondition, includeUnavailableTransitions, sortByOpsBarAndStatus);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get transitions Returns either all transitions or a transition that can be performed by the user on an issue, based on the issue&#39;s status.  Note, if a request is made for a transition that does not exist or cannot be performed on the issue, given its status, the response will return any empty transitions list.  This operation can be accessed anonymously.  **[Permissions](#permissions) required: A list or transition is returned only when the user has:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  However, if the user does not have the *Transition issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) the response will not list any transitions.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about transitions in the response. This parameter accepts &#x60;transitions.fields&#x60;, which returns information about the fields in the transition screen for each transition. Fields hidden from the screen are not returned. Use this information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Transition issue](#api-rest-api-2-issue-issueIdOrKey-transitions-post). (optional)</param>
        /// <param name="transitionId">The ID of the transition. (optional)</param>
        /// <param name="skipRemoteOnlyCondition">Whether transitions with the condition *Hide From User Condition* are included in the response. (optional, default to false)</param>
        /// <param name="includeUnavailableTransitions">Whether details of transitions that fail a condition are included in the response (optional, default to false)</param>
        /// <param name="sortByOpsBarAndStatus">Whether the transitions are sorted by ops-bar sequence value first then category order (Todo, In Progress, Done) or only by ops-bar sequence value. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Transitions</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<Transitions> GetTransitionsWithHttpInfo(string issueIdOrKey, string? expand = default(string?), string? transitionId = default(string?), bool? skipRemoteOnlyCondition = default(bool?), bool? includeUnavailableTransitions = default(bool?), bool? sortByOpsBarAndStatus = default(bool?), int operationIndex = 0)
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->GetTransitions");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            if (expand != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "expand", expand));
            }
            if (transitionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "transitionId", transitionId));
            }
            if (skipRemoteOnlyCondition != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "skipRemoteOnlyCondition", skipRemoteOnlyCondition));
            }
            if (includeUnavailableTransitions != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "includeUnavailableTransitions", includeUnavailableTransitions));
            }
            if (sortByOpsBarAndStatus != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "sortByOpsBarAndStatus", sortByOpsBarAndStatus));
            }

            localVarRequestOptions.Operation = "IssuesApi.GetTransitions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Get<Transitions>("/rest/api/2/issue/{issueIdOrKey}/transitions", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTransitions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Get transitions Returns either all transitions or a transition that can be performed by the user on an issue, based on the issue&#39;s status.  Note, if a request is made for a transition that does not exist or cannot be performed on the issue, given its status, the response will return any empty transitions list.  This operation can be accessed anonymously.  **[Permissions](#permissions) required: A list or transition is returned only when the user has:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  However, if the user does not have the *Transition issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) the response will not list any transitions.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about transitions in the response. This parameter accepts &#x60;transitions.fields&#x60;, which returns information about the fields in the transition screen for each transition. Fields hidden from the screen are not returned. Use this information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Transition issue](#api-rest-api-2-issue-issueIdOrKey-transitions-post). (optional)</param>
        /// <param name="transitionId">The ID of the transition. (optional)</param>
        /// <param name="skipRemoteOnlyCondition">Whether transitions with the condition *Hide From User Condition* are included in the response. (optional, default to false)</param>
        /// <param name="includeUnavailableTransitions">Whether details of transitions that fail a condition are included in the response (optional, default to false)</param>
        /// <param name="sortByOpsBarAndStatus">Whether the transitions are sorted by ops-bar sequence value first then category order (Todo, In Progress, Done) or only by ops-bar sequence value. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Transitions</returns>
        public async System.Threading.Tasks.Task<Transitions> GetTransitionsAsync(string issueIdOrKey, string? expand = default(string?), string? transitionId = default(string?), bool? skipRemoteOnlyCondition = default(bool?), bool? includeUnavailableTransitions = default(bool?), bool? sortByOpsBarAndStatus = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<Transitions> localVarResponse = await GetTransitionsWithHttpInfoAsync(issueIdOrKey, expand, transitionId, skipRemoteOnlyCondition, includeUnavailableTransitions, sortByOpsBarAndStatus, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Get transitions Returns either all transitions or a transition that can be performed by the user on an issue, based on the issue&#39;s status.  Note, if a request is made for a transition that does not exist or cannot be performed on the issue, given its status, the response will return any empty transitions list.  This operation can be accessed anonymously.  **[Permissions](#permissions) required: A list or transition is returned only when the user has:**   *  *Browse projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.  However, if the user does not have the *Transition issues* [ project permission](https://confluence.atlassian.com/x/yodKLg) the response will not list any transitions.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">The ID or key of the issue.</param>
        /// <param name="expand">Use [expand](#expansion) to include additional information about transitions in the response. This parameter accepts &#x60;transitions.fields&#x60;, which returns information about the fields in the transition screen for each transition. Fields hidden from the screen are not returned. Use this information to populate the &#x60;fields&#x60; and &#x60;update&#x60; fields in [Transition issue](#api-rest-api-2-issue-issueIdOrKey-transitions-post). (optional)</param>
        /// <param name="transitionId">The ID of the transition. (optional)</param>
        /// <param name="skipRemoteOnlyCondition">Whether transitions with the condition *Hide From User Condition* are included in the response. (optional, default to false)</param>
        /// <param name="includeUnavailableTransitions">Whether details of transitions that fail a condition are included in the response (optional, default to false)</param>
        /// <param name="sortByOpsBarAndStatus">Whether the transitions are sorted by ops-bar sequence value first then category order (Todo, In Progress, Done) or only by ops-bar sequence value. (optional, default to false)</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Transitions)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<Transitions>> GetTransitionsWithHttpInfoAsync(string issueIdOrKey, string? expand = default(string?), string? transitionId = default(string?), bool? skipRemoteOnlyCondition = default(bool?), bool? includeUnavailableTransitions = default(bool?), bool? sortByOpsBarAndStatus = default(bool?), int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->GetTransitions");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            if (expand != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "expand", expand));
            }
            if (transitionId != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "transitionId", transitionId));
            }
            if (skipRemoteOnlyCondition != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "skipRemoteOnlyCondition", skipRemoteOnlyCondition));
            }
            if (includeUnavailableTransitions != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "includeUnavailableTransitions", includeUnavailableTransitions));
            }
            if (sortByOpsBarAndStatus != null)
            {
                localVarRequestOptions.QueryParameters.Add(Projects.JiraPlatformApi.Client.ClientUtils.ParameterToMultiMap("", "sortByOpsBarAndStatus", sortByOpsBarAndStatus));
            }

            localVarRequestOptions.Operation = "IssuesApi.GetTransitions";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.GetAsync<Transitions>("/rest/api/2/issue/{issueIdOrKey}/transitions", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("GetTransitions", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send notification for issue Creates an email notification for an issue and adds it to the mail queue.  **[Permissions](#permissions) required:**   *  *Browse Projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">ID or key of the issue that the notification is sent for.</param>
        /// <param name="notification">The request object for the notification and recipients.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>Object</returns>
        public Object Notify(string issueIdOrKey, Notification notification, int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<Object> localVarResponse = NotifyWithHttpInfo(issueIdOrKey, notification);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Send notification for issue Creates an email notification for an issue and adds it to the mail queue.  **[Permissions](#permissions) required:**   *  *Browse Projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">ID or key of the issue that the notification is sent for.</param>
        /// <param name="notification">The request object for the notification and recipients.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of Object</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<Object> NotifyWithHttpInfo(string issueIdOrKey, Notification notification, int operationIndex = 0)
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->Notify");
            }

            // verify the required parameter 'notification' is set
            if (notification == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'notification' when calling IssuesApi->Notify");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            localVarRequestOptions.Data = notification;

            localVarRequestOptions.Operation = "IssuesApi.Notify";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Post<Object>("/rest/api/2/issue/{issueIdOrKey}/notify", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("Notify", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Send notification for issue Creates an email notification for an issue and adds it to the mail queue.  **[Permissions](#permissions) required:**   *  *Browse Projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">ID or key of the issue that the notification is sent for.</param>
        /// <param name="notification">The request object for the notification and recipients.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of Object</returns>
        public async System.Threading.Tasks.Task<Object> NotifyAsync(string issueIdOrKey, Notification notification, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<Object> localVarResponse = await NotifyWithHttpInfoAsync(issueIdOrKey, notification, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Send notification for issue Creates an email notification for an issue and adds it to the mail queue.  **[Permissions](#permissions) required:**   *  *Browse Projects* [project permission](https://confluence.atlassian.com/x/yodKLg) for the project that the issue is in.  *  If [issue-level security](https://confluence.atlassian.com/x/J4lKLg) is configured, issue-level security permission to view the issue.
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueIdOrKey">ID or key of the issue that the notification is sent for.</param>
        /// <param name="notification">The request object for the notification and recipients.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (Object)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<Object>> NotifyWithHttpInfoAsync(string issueIdOrKey, Notification notification, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'issueIdOrKey' is set
            if (issueIdOrKey == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueIdOrKey' when calling IssuesApi->Notify");
            }

            // verify the required parameter 'notification' is set
            if (notification == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'notification' when calling IssuesApi->Notify");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.PathParameters.Add("issueIdOrKey", Projects.JiraPlatformApi.Client.ClientUtils.ParameterToString(issueIdOrKey)); // path parameter
            localVarRequestOptions.Data = notification;

            localVarRequestOptions.Operation = "IssuesApi.Notify";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PostAsync<Object>("/rest/api/2/issue/{issueIdOrKey}/notify", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("Notify", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Unarchive issue(s) by issue keys/ID Enables admins to unarchive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) unarchived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t unarchive subtasks directly, only through their parent issues  *  you can only unarchive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be unarchived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>IssueArchivalSyncResponse</returns>
        public IssueArchivalSyncResponse UnarchiveIssues(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0)
        {
            Projects.JiraPlatformApi.Client.ApiResponse<IssueArchivalSyncResponse> localVarResponse = UnarchiveIssuesWithHttpInfo(issueArchivalSyncRequest);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Unarchive issue(s) by issue keys/ID Enables admins to unarchive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) unarchived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t unarchive subtasks directly, only through their parent issues  *  you can only unarchive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be unarchived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <returns>ApiResponse of IssueArchivalSyncResponse</returns>
        public Projects.JiraPlatformApi.Client.ApiResponse<IssueArchivalSyncResponse> UnarchiveIssuesWithHttpInfo(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0)
        {
            // verify the required parameter 'issueArchivalSyncRequest' is set
            if (issueArchivalSyncRequest == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueArchivalSyncRequest' when calling IssuesApi->UnarchiveIssues");
            }

            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = issueArchivalSyncRequest;

            localVarRequestOptions.Operation = "IssuesApi.UnarchiveIssues";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = this.Client.Put<IssueArchivalSyncResponse>("/rest/api/2/issue/unarchive", localVarRequestOptions, this.Configuration);
            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UnarchiveIssues", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

        /// <summary>
        /// Unarchive issue(s) by issue keys/ID Enables admins to unarchive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) unarchived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t unarchive subtasks directly, only through their parent issues  *  you can only unarchive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be unarchived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of IssueArchivalSyncResponse</returns>
        public async System.Threading.Tasks.Task<IssueArchivalSyncResponse> UnarchiveIssuesAsync(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            Projects.JiraPlatformApi.Client.ApiResponse<IssueArchivalSyncResponse> localVarResponse = await UnarchiveIssuesWithHttpInfoAsync(issueArchivalSyncRequest, operationIndex, cancellationToken).ConfigureAwait(false);
            return localVarResponse.Data;
        }

        /// <summary>
        /// Unarchive issue(s) by issue keys/ID Enables admins to unarchive up to 1000 issues in a single request using issue ID/key, returning details of the issue(s) unarchived in the process and the errors encountered, if any.  **Note that:**   *  you can&#39;t unarchive subtasks directly, only through their parent issues  *  you can only unarchive issues from software, service management, and business projects  **[Permissions](#permissions) required:** Jira admin or site admin: [global permission](https://confluence.atlassian.com/x/x4dKLg)  **License required:** Premium or Enterprise  **Signed-in users only:** This API can&#39;t be accessed anonymously.     
        /// </summary>
        /// <exception cref="Projects.JiraPlatformApi.Client.ApiException">Thrown when fails to make API call</exception>
        /// <param name="issueArchivalSyncRequest">Contains a list of issue keys or IDs to be unarchived.</param>
        /// <param name="operationIndex">Index associated with the operation.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse (IssueArchivalSyncResponse)</returns>
        public async System.Threading.Tasks.Task<Projects.JiraPlatformApi.Client.ApiResponse<IssueArchivalSyncResponse>> UnarchiveIssuesWithHttpInfoAsync(IssueArchivalSyncRequest issueArchivalSyncRequest, int operationIndex = 0, System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // verify the required parameter 'issueArchivalSyncRequest' is set
            if (issueArchivalSyncRequest == null)
            {
                throw new Projects.JiraPlatformApi.Client.ApiException(400, "Missing required parameter 'issueArchivalSyncRequest' when calling IssuesApi->UnarchiveIssues");
            }


            Projects.JiraPlatformApi.Client.RequestOptions localVarRequestOptions = new Projects.JiraPlatformApi.Client.RequestOptions();

            string[] _contentTypes = new string[] {
                "application/json"
            };

            // to determine the Accept header
            string[] _accepts = new string[] {
                "application/json"
            };

            var localVarContentType = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderContentType(_contentTypes);
            if (localVarContentType != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Content-Type", localVarContentType);
            }

            var localVarAccept = Projects.JiraPlatformApi.Client.ClientUtils.SelectHeaderAccept(_accepts);
            if (localVarAccept != null)
            {
                localVarRequestOptions.HeaderParameters.Add("Accept", localVarAccept);
            }

            localVarRequestOptions.Data = issueArchivalSyncRequest;

            localVarRequestOptions.Operation = "IssuesApi.UnarchiveIssues";
            localVarRequestOptions.OperationIndex = operationIndex;

            // authentication (OAuth2) required
            // oauth required
            if (!localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                if (!string.IsNullOrEmpty(this.Configuration.AccessToken))
                {
                    localVarRequestOptions.HeaderParameters.Add("Authorization", "Bearer " + this.Configuration.AccessToken);
                }
                else if (!string.IsNullOrEmpty(this.Configuration.OAuthTokenUrl) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientId) &&
                         !string.IsNullOrEmpty(this.Configuration.OAuthClientSecret) &&
                         this.Configuration.OAuthFlow != null)
                {
                    localVarRequestOptions.OAuth = true;
                }
            }
            // authentication (basicAuth) required
            // http basic authentication required
            if (!string.IsNullOrEmpty(this.Configuration.Username) || !string.IsNullOrEmpty(this.Configuration.Password) && !localVarRequestOptions.HeaderParameters.ContainsKey("Authorization"))
            {
                localVarRequestOptions.HeaderParameters.Add("Authorization", "Basic " + Projects.JiraPlatformApi.Client.ClientUtils.Base64Encode(this.Configuration.Username + ":" + this.Configuration.Password));
            }

            // make the HTTP request
            var localVarResponse = await this.AsynchronousClient.PutAsync<IssueArchivalSyncResponse>("/rest/api/2/issue/unarchive", localVarRequestOptions, this.Configuration, cancellationToken).ConfigureAwait(false);

            if (this.ExceptionFactory != null)
            {
                Exception _exception = this.ExceptionFactory("UnarchiveIssues", localVarResponse);
                if (_exception != null)
                {
                    throw _exception;
                }
            }

            return localVarResponse;
        }

    }
}
